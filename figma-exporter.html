<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DA Auto Test Generator from Figma</title>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' https://api.figma.com https://api.mistral.ai https://s3-alpha-sig.figma.com https://figma-alpha-api.s3.us-west-2.amazonaws.com https://*.amazonaws.com; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
            max-width: 600px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 28px;
            margin-bottom: 10px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 16px;
        }

        .credentials {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .credential-item {
            margin-bottom: 15px;
        }

        .credential-item:last-child {
            margin-bottom: 0;
        }

        .credential-item label {
            display: block;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .credential-item input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            background: white;
            transition: border-color 0.2s;
        }

        .credential-item input:focus {
            outline: none;
            border-color: #667eea;
        }

        .export-button {
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 16px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 20px;
        }

        .export-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .export-button:active {
            transform: translateY(0);
        }

        .export-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .unified-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.4);
        }

        .unified-button:disabled {
            transform: none;
            box-shadow: none;
        }

        .status {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-size: 14px;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .progress {
            margin-top: 20px;
            display: none;
        }

        .progress-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            position: relative;
        }

        .progress-step {
            flex: 1;
            text-align: center;
            position: relative;
            padding: 10px 5px;
        }

        .progress-step::after {
            content: '';
            position: absolute;
            top: 25px;
            right: -50%;
            width: 100%;
            height: 2px;
            background: #e9ecef;
            z-index: 1;
        }

        .progress-step:last-child::after {
            display: none;
        }

        .progress-step.active::after {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .step-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #e9ecef;
            color: #6c757d;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 8px;
            font-weight: bold;
            position: relative;
            z-index: 2;
            transition: all 0.3s ease;
        }

        .progress-step.active .step-icon {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            transform: scale(1.15);
            animation: activeBlink 1s infinite, pulse 2s infinite;
            border: 2px solid #ff6b35;
        }

        .progress-step.processing .step-icon {
            background: linear-gradient(135deg, #ffc107 0%, #ff8f00 100%);
            color: white;
            transform: scale(1.1);
            animation: processingBlink 0.8s infinite;
            border: 2px solid #ffc107;
        }

        @keyframes activeBlink {
            0%, 50% {
                opacity: 1;
                background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            }
            25%, 75% {
                opacity: 0.7;
                background: linear-gradient(135deg, #f7931e 0%, #ff6b35 100%);
            }
        }

        @keyframes processingBlink {
            0% {
                opacity: 1;
                transform: scale(1.1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.05);
            }
            100% {
                opacity: 1;
                transform: scale(1.1);
            }
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 107, 53, 0.7);
            }
            70% {
                box-shadow: 0 0 0 15px rgba(255, 107, 53, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 107, 53, 0);
            }
        }

        .progress-step.completed .step-icon {
            background: #28a745;
            color: white;
        }

        .progress-step.completed .step-icon::after {
            content: '‚úì';
            position: absolute;
            font-size: 16px;
            font-weight: bold;
        }

        .step-title {
            font-size: 12px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .step-description {
            font-size: 10px;
            color: #6c757d;
        }

        .progress-step.active .step-title {
            color: #667eea;
            font-weight: bold;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 5px #667eea;
            }
            to {
                text-shadow: 0 0 10px #667eea, 0 0 15px #667eea;
            }
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #e9ecef;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 6px;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background-image: 
                linear-gradient(
                    -45deg,
                    rgba(255, 255, 255, .2) 25%,
                    transparent 25%,
                    transparent 50%,
                    rgba(255, 255, 255, .2) 50%,
                    rgba(255, 255, 255, .2) 75%,
                    transparent 75%,
                    transparent
                );
            background-size: 50px 50px;
            animation: move 2s linear infinite;
        }

        @keyframes move {
            0% {
                background-position: 0 0;
            }
            100% {
                background-position: 50px 50px;
            }
        }

        .progress-text {
            text-align: center;
            font-size: 14px;
            color: #495057;
            font-weight: 500;
        }

        .progress-percentage {
            text-align: center;
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
        }

        .frame-list {
            margin-top: 20px;
            display: none;
        }

        .frame-item {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .frame-name {
            font-weight: 500;
            color: #2c3e50;
        }

        .frame-status {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            background: #e9ecef;
            color: #6c757d;
        }

        .frame-status.downloading {
            background: #fff3cd;
            color: #856404;
        }

        .frame-status.completed {
            background: #d4edda;
            color: #155724;
        }

        .frame-status.failed {
            background: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>DA: Auto Test Generator from Figma using AI & auto Execution on Device</h1>
            <p>Generate and validate test case & auto execute on real device</p>
        </div>

        <!-- Application Description Section -->
        <div class="description-section" style="background: #e8f4fd; border-radius: 8px; padding: 15px 20px; margin-bottom: 30px; border-left: 4px solid #007bff;">
            <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleDescription()">
                <h3 style="color: #0056b3; margin: 0; font-size: 18px;">How This Application Works</h3>
                <span id="descriptionToggle" style="color: #007bff; font-size: 20px; font-weight: bold;">‚ñº</span>
            </div>
            <div id="descriptionContent" style="margin-top: 15px; color: #495057; line-height: 1.6;">
                <div style="margin-bottom: 12px; padding: 12px; background: rgba(0,123,255,0.1); border-radius: 6px; border-left: 4px solid #007bff;">
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <span style="background: #007bff; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; margin-right: 10px;">1</span>
                        <strong style="color: #0056b3;">üîó Figma Integration</strong>
                    </div>
                    <span style="color: #6c757d; font-size: 14px; margin-left: 34px; display: block;">Connects to your Figma project using API tokens to extract design frames and interactive prototype data.</span>
                </div>
                <div style="margin-bottom: 12px; padding: 12px; background: rgba(220,53,69,0.1); border-radius: 6px; border-left: 4px solid #dc3545;">
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <span style="background: #dc3545; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; margin-right: 10px;">2</span>
                        <strong style="color: #dc3545;">üìä JSON Extraction</strong>
                    </div>
                    <span style="color: #6c757d; font-size: 14px; margin-left: 34px; display: block;">Processes Figma's design JSON to identify frames, interactions, clickable elements, and navigation flows.</span>
                </div>
                <div style="margin-bottom: 12px; padding: 12px; background: rgba(255,193,7,0.1); border-radius: 6px; border-left: 4px solid #ffc107;">
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <span style="background: #ffc107; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; margin-right: 10px;">3</span>
                        <strong style="color: #ffc107;">ü§ñ AI-Powered Analysis</strong>
                    </div>
                    <span style="color: #6c757d; font-size: 14px; margin-left: 34px; display: block;">Sends extracted data to Mistral AI models to intelligently generate automated test cases based on your prototype interactions.</span>
                </div>
                <div style="margin-bottom: 12px; padding: 12px; background: rgba(40,167,69,0.1); border-radius: 6px; border-left: 4px solid #28a745;">
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <span style="background: #28a745; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; margin-right: 10px;">4</span>
                        <strong style="color: #28a745;">üß™ Test Case Generation</strong>
                    </div>
                    <span style="color: #6c757d; font-size: 14px; margin-left: 34px; display: block;">Creates precise test scripts with coordinates, actions (CLICK, SLEEP, CHECK), and validation steps for comprehensive testing.</span>
                </div>
                <div style="margin-bottom: 0px; padding: 12px; background: rgba(102,126,234,0.1); border-radius: 6px; border-left: 4px solid #667eea;">
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <span style="background: #667eea; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; margin-right: 10px;">5</span>
                        <strong style="color: #667eea;">‚ö° Auto Execution</strong>
                    </div>
                    <span style="color: #6c757d; font-size: 14px; margin-left: 34px; display: block;">Downloads test cases and automatically launches testexecutor.bat on desktop to execute tests on real devices.</span>
                </div>
            </div>
        </div>

        <div class="credentials">
            <div class="credential-item">
                <label for="apiToken">Figma API Token</label>
                <input type="password" id="apiToken" value="figd_2nGk49M9ujxccf01lNpgv3gGfqKaRQ74Q0jBhzn1" style="background: #fff; border: 1px solid #ced4da; font-family: monospace;">
            </div>
            <div class="credential-item">
                <label for="fileId">Figma File ID</label>
                <input type="text" id="fileId" value="2k2t7ZfG09nLyjM4viAGHP" style="background: #fff; border: 1px solid #ced4da; font-family: monospace;">
            </div>
        </div>

        <!-- AI Configuration Section -->
        <div class="ai-config-section" style="margin-bottom: 30px; background: #fff3cd; border-radius: 8px; border: 1px solid #ffeaa7;">
            <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px 20px;" onclick="toggleAIConfig()">
                <h3 style="color: #856404; margin: 0; font-size: 16px;">ü§ñ AI Configuration</h3>
                <span id="aiConfigToggle" style="color: #856404; font-size: 20px; font-weight: bold;">‚ñ∂</span>
            </div>
            <div id="aiConfigContent" style="display: none; padding: 0 20px 20px 20px;">
                <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 193, 7, 0.1); border-radius: 6px; border-left: 4px solid #ffc107;">
                    <div style="font-size: 13px; color: #856404; font-weight: 600; margin-bottom: 5px;">üí° Configuration Options</div>
                    <div style="font-size: 12px; color: #6c757d;">
                        ‚Ä¢ <strong>Mistral AI:</strong> https://api.mistral.ai (Default)<br>
                        ‚Ä¢ <strong>Local Ollama:</strong> http://localhost:11434<br>
                        ‚Ä¢ <strong>Local LM Studio:</strong> http://localhost:1234<br>
                        ‚Ä¢ <strong>OpenAI:</strong> https://api.openai.com<br>
                        ‚Ä¢ <strong>Groq:</strong> https://api.groq.com<br>
                        ‚Ä¢ <strong>Custom Local:</strong> Your own deployment URL
                    </div>
                </div>
                <div class="credential-item">
                    <label for="aiApiUrl">AI API Base URL</label>
                    <input type="text" id="aiApiUrl" value="https://api.mistral.ai" style="background: #fff; border: 1px solid #ced4da; font-family: monospace;" placeholder="https://api.mistral.ai">
                </div>
                <div class="credential-item">
                    <label for="aiApiKey">AI API Key</label>
                    <input type="password" id="aiApiKey" value="gmEWLMGdvQ4loD8fJ1bO70eknyEgA35x" style="background: #fff; border: 1px solid #ced4da; font-family: monospace;" placeholder="Your AI API key">
                </div>
                <div class="credential-item" style="margin-bottom: 0;">
                    <label for="aiModel">AI Model</label>
                    <input type="text" id="aiModel" value="mistral-large-latest" style="background: #fff; border: 1px solid #ced4da; font-family: monospace;" placeholder="mistral-large-latest">
                    <div style="font-size: 11px; color: #6c757d; margin-top: 5px;">
                        Examples: mistral-large-latest, llama3-8b-8192, gpt-4, claude-3-haiku-20240307
                    </div>
                </div>
            </div>
        </div>

        <button class="export-button unified-button" id="unifiedButton" style="background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%); font-size: 18px; font-weight: bold; padding: 20px 24px; transition: all 0.3s ease;">üöÄ Generate Test Cases with AI & Auto Execute using Test Executor</button>

        <!-- AI Prompt Display Section -->
        <div class="prompt-section" id="promptSection" style="display: none; background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px; border: 1px solid #dee2e6;">
            <h4 style="color: #2c3e50; margin-bottom: 15px; display: flex; align-items: center;">
                ü§ñ AI Prompt Being Sent to Mistral
                <button id="togglePrompt" style="margin-left: auto; padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">Show/Hide</button>
            </h4>
            <div id="promptContent" style="display: none;">
                <textarea id="promptText" readonly style="width: 100%; height: 300px; padding: 15px; border: 1px solid #ced4da; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 11px; background: #fff; resize: vertical;"></textarea>
                <div style="margin-top: 10px; font-size: 12px; color: #6c757d;">
                    <strong>Note:</strong> This is the actual prompt being sent to Mistral AI with your Figma data for test case generation.
                </div>
            </div>
        </div>

        <div class="status" id="status"></div>

        <div class="progress" id="progress">
            <!-- Progress Steps -->
            <div class="progress-steps" id="progressSteps">
                <div class="progress-step" id="step1">
                    <div class="step-icon">1</div>
                    <div class="step-title">Connect</div>
                    <div class="step-description">Figma API</div>
                </div>
                <div class="progress-step" id="step2">
                    <div class="step-icon">2</div>
                    <div class="step-title">Extract</div>
                    <div class="step-description">Design Data</div>
                </div>
                <div class="progress-step" id="step3">
                    <div class="step-icon">3</div>
                    <div class="step-title">AI Analysis</div>
                    <div class="step-description">Mistral AI</div>
                </div>
                <div class="progress-step" id="step4">
                    <div class="step-icon">4</div>
                    <div class="step-title">Generate</div>
                    <div class="step-description">Test Cases</div>
                </div>
                <div class="progress-step" id="step5">
                    <div class="step-icon">5</div>
                    <div class="step-title">Execute</div>
                    <div class="step-description">Auto Run</div>
                </div>
            </div>
            
            <!-- Progress Bar -->
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Preparing export...</div>
            <div class="progress-percentage" id="progressPercentage">0%</div>
        </div>

        <div class="frame-list" id="frameList"></div>

        <!-- Console Output Window -->
        <div class="console-window" id="consoleWindow" style="display: none; margin-top: 20px; background: #1e1e1e; border-radius: 8px; border: 1px solid #333;">
            <div style="background: #333; padding: 10px 15px; border-radius: 8px 8px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <h4 style="color: #fff; margin: 0; font-size: 14px;">üñ•Ô∏è Test Executor Console Output</h4>
                <div>
                    <button id="clearConsole" style="padding: 4px 8px; background: #666; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; margin-right: 5px;">Clear</button>
                    <button id="closeConsole" style="padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">Close</button>
                </div>
            </div>
            <div id="consoleOutput" style="padding: 15px; color: #00ff00; font-family: 'Courier New', monospace; font-size: 12px; height: 300px; overflow-y: auto; background: #1e1e1e;">
                <div style="color: #888;">Test Executor Console - Ready</div>
            </div>
        </div>

        <!-- Individual Operations Section -->
        <div class="individual-sections" style="margin-top: 30px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
            <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px 20px;" onclick="toggleIndividualOperations()">
                <h3 style="color: #2c3e50; margin: 0; font-size: 16px;">‚öôÔ∏è Individual Operations</h3>
                <span id="individualToggle" style="color: #007bff; font-size: 20px; font-weight: bold;">‚ñº</span>
            </div>
            <div id="individualContent" style="display: none; padding: 0 20px 20px 20px;">
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button class="export-button" id="exportButton" style="flex: 1; padding: 12px; font-size: 14px; height: 48px; display: flex; align-items: center; justify-content: center; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer;">üì• Export Frames Only</button>
                    <button class="ai-button" id="generateTestCasesButton" style="flex: 1; padding: 12px; background: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; height: 48px; display: flex; align-items: center; justify-content: center;">ü§ñ AI Test Cases Only</button>
                </div>
                <div id="testCaseOutput" style="display: none; margin-top: 15px;">
                    <h4 style="color: #2c3e50; margin-bottom: 10px;">Generated Test Cases:</h4>
                    <textarea id="testCaseText" readonly style="width: 100%; height: 200px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 12px; background: #f8f9fa;"></textarea>
                    <button id="downloadTestCases" style="margin-top: 10px; padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Download testcases.txt</button>
                </div>
            </div>
        </div>

        <!-- Manual Test Execution Section -->
        <div class="exe-section" style="margin-top: 20px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
            <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px 20px;" onclick="toggleManualExecution()">
                <h3 style="color: #2c3e50; margin: 0; font-size: 16px;">üñ•Ô∏è Manual Test Execution</h3>
                <span id="manualToggle" style="color: #007bff; font-size: 20px; font-weight: bold;">‚ñº</span>
            </div>
            <div id="manualContent" style="display: none; padding: 0 20px 20px 20px;">
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button class="exe-button" id="selectExeButton" style="flex: 1; padding: 12px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">üìÇ Select .exe File</button>
                    <button class="exe-button" id="runExeButton" style="flex: 1; padding: 12px; background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;" disabled>‚ñ∂Ô∏è Run Selected Exe</button>
                </div>
                <div id="selectedExePath" style="font-size: 12px; color: #6c757d; word-break: break-all; font-style: italic;"></div>
            </div>
        </div>
    </div>

    <script>
        class FigmaExporter {
            constructor() {
                this.apiToken = document.getElementById('apiToken').value;
                this.fileId = document.getElementById('fileId').value;
                this.baseUrl = 'https://api.figma.com/v1';
                this.frames = [];
                this.exportedCount = 0;
                
                this.initializeEventListeners();
            }

            // Get current AI configuration from UI
            getAIConfig() {
                return {
                    apiUrl: document.getElementById('aiApiUrl').value || 'https://api.mistral.ai',
                    apiKey: document.getElementById('aiApiKey').value,
                    model: document.getElementById('aiModel').value || 'mistral-large-latest'
                };
            }

            initializeEventListeners() {
                document.getElementById('exportButton').addEventListener('click', () => {
                    this.exportAllFrames();
                });

                // Exe runner event listeners
                document.getElementById('selectExeButton').addEventListener('click', () => {
                    this.selectExeFile();
                });

                document.getElementById('runExeButton').addEventListener('click', () => {
                    this.runSelectedExe();
                });

                // AI test case generator event listeners
                document.getElementById('generateTestCasesButton').addEventListener('click', () => {
                    this.generateTestCases();
                });

                document.getElementById('downloadTestCases').addEventListener('click', () => {
                    this.downloadTestCases();
                });

                // Unified button event listener
                document.getElementById('unifiedButton').addEventListener('click', () => {
                    this.runUnifiedProcess();
                });

                // Prompt toggle event listener
                document.getElementById('togglePrompt').addEventListener('click', () => {
                    this.togglePromptDisplay();
                });

                // Console window event listeners
                document.getElementById('clearConsole').addEventListener('click', () => {
                    this.clearConsoleOutput();
                });

                document.getElementById('closeConsole').addEventListener('click', () => {
                    this.hideConsoleWindow();
                });
            }

            // Unified process that runs everything in sequence
            async runUnifiedProcess() {
                const unifiedButton = document.getElementById('unifiedButton');
                const originalText = unifiedButton.textContent;
                unifiedButton.disabled = true;
                unifiedButton.textContent = 'üîÑ Processing Everything...';
                
                this.hideStatus();
                this.showProgress();
                
                try {
                    this.showStatus('Starting unified process: Frames + Test Cases', 'info');
                    
                    // Step 1: Connect to Figma API
                    this.markStepProcessing(1);
                    this.updateProgress(5, 'Connecting to Figma API...', 1);
                    const frames = await this.getFrames();
                    this.markStepCompleted(1);
                    
                    // Step 2: Extract design data
                    this.markStepProcessing(2);
                    this.updateProgress(20, 'Extracting design data and interactions...', 2);
                    const fileData = await this.makeApiRequest(`/files/${this.fileId}?geometry=paths`);
                    this.markStepCompleted(2);
                    
                    // Step 3: AI Analysis with Prompt Display
                    this.markStepProcessing(3);
                    this.updateProgress(35, 'Preparing AI analysis with Mistral...', 3);
                    
                    // Create and display the prompt being sent to Mistral
                    const prototypeData = this.extractPrototypeData(fileData);
                    const prompt = this.createMistralPrompt(prototypeData);
                    this.showPromptSection(prompt);
                    
                    let testResult;
                    
                    // Check if running in desktop mode (Electron) vs web browser
                    console.log('Desktop detection - window.electronAPI:', !!window.electronAPI);
                    if (window.electronAPI) {
                        // Desktop mode - make direct API call to Mistral
                        console.log('Using desktop mode for test case generation');
                        this.updateProgress(40, 'Calling AI directly from desktop...', 3);
                        testResult = await this.generateTestCasesDesktop(fileData);
                    } else {
                        // Web mode - use Express server
                        const aiConfig = this.getAIConfig();
                        const response = await fetch('/api/generate-test-cases', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ 
                                figmaData: fileData, 
                                aiConfig: aiConfig
                            })
                        });

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({}));
                            throw new Error(`AI Error ${response.status}: ${errorData.message || response.statusText}`);
                        }

                        testResult = await response.json();
                    }
                    if (!testResult.success || !testResult.testCases) {
                        throw new Error(testResult.message || 'Failed to generate test cases');
                    }
                    this.markStepCompleted(3);

                    // Step 4: Generate test cases
                    this.markStepProcessing(4);
                    this.updateProgress(60, 'Generating test cases...', 4);
                    
                    // Process frames in chunks and download
                    this.showFrameList();
                    frames.forEach(frame => this.addFrameToList(frame));
                    
                    const chunkSize = 50;
                    const chunks = [];
                    for (let i = 0; i < frames.length; i += chunkSize) {
                        chunks.push(frames.slice(i, i + chunkSize));
                    }

                    for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                        const chunk = chunks[chunkIndex];
                        const frameIds = chunk.map(f => f.id);
                        
                        const imageUrls = await this.exportFrames(frameIds);
                        
                        const downloadPromises = chunk.map(frame => {
                            const imageUrl = imageUrls[frame.id];
                            if (imageUrl) {
                                return this.downloadImage(frame.id, imageUrl, frame.name);
                            } else {
                                this.updateFrameStatus(frame.id, 'failed', 'No URL');
                                return Promise.resolve();
                            }
                        });
                        
                        await Promise.all(downloadPromises);
                        
                        if (chunkIndex < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }

                    // Display and download test cases
                    this.displayTestCases(testResult.testCases);
                    
                    // Auto-download test cases
                    if (window.electronAPI) {
                        await this.saveTestCasesDesktop();
                    } else {
                        this.saveTestCasesWeb();
                    }
                    this.markStepCompleted(4);
                    
                    // Step 5: Auto execute (desktop only)
                    this.markStepProcessing(5);
                    this.updateProgress(90, 'Preparing auto execution...', 5);
                    
                    // Run testexecutor.bat if on desktop
                    if (window.electronAPI) {
                        try {
                            await this.runTestExecutor();
                            this.markStepCompleted(5);
                            this.updateProgress(100, 'Complete! Test executor launched successfully', 5);
                            this.showStatus(`‚úÖ Success! Downloaded ${frames.length} frames, generated ${testResult.testCases.split('\n').filter(line => line.trim()).length} test cases, and launched test executor`, 'success');
                        } catch (error) {
                            this.markStepCompleted(5);
                            this.updateProgress(100, 'Complete! Files downloaded (Test executor failed)', 5);
                            this.showStatus(`‚úÖ Partial Success! Downloaded ${frames.length} frames and generated test cases, but test executor failed: ${error.message}`, 'info');
                        }
                    } else {
                        this.markStepCompleted(5);
                        this.updateProgress(100, 'Complete! All frames and test cases downloaded', 5);
                        this.showStatus(`‚úÖ Success! Downloaded ${frames.length} frames and generated ${testResult.testCases.split('\n').filter(line => line.trim()).length} test cases. Use desktop version for auto execution.`, 'success');
                    }

                } catch (error) {
                    this.showStatus(`Error in unified process: ${error.message}`, 'error');
                    console.error('Unified process error:', error);
                } finally {
                    // Keep progress visible but stop animations
                    const progressSteps = document.querySelectorAll('.progress-step');
                    progressSteps.forEach(step => {
                        step.classList.remove('active', 'processing');
                        if (!step.classList.contains('completed')) {
                            step.classList.add('completed');
                        }
                    });
                    
                    // Hide progress bar but keep steps visible
                    document.getElementById('progressFill').style.display = 'none';
                    document.getElementById('progressText').style.display = 'none';
                    document.getElementById('progressPercentage').style.display = 'none';
                    
                    // Change button to green when completed
                    unifiedButton.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                    unifiedButton.innerHTML = '‚úÖ Task Completed Successfully';
                    
                    unifiedButton.disabled = false;
                    
                    // Reset button after 3 seconds
                    setTimeout(() => {
                        unifiedButton.style.background = 'linear-gradient(135deg, #ffc107 0%, #fd7e14 100%)';
                        unifiedButton.textContent = originalText;
                    }, 3000);
                }
            }

            // Enhanced Progress Management
            updateProgressSteps(currentStep) {
                const steps = ['step1', 'step2', 'step3', 'step4', 'step5'];
                
                steps.forEach((stepId, index) => {
                    const stepElement = document.getElementById(stepId);
                    stepElement.classList.remove('active', 'completed', 'processing');
                    
                    if (index < currentStep - 1) {
                        stepElement.classList.add('completed');
                    } else if (index === currentStep - 1) {
                        stepElement.classList.add('active');
                    }
                });
            }

            // Keep steps visible and mark as completed without hiding
            markStepCompleted(stepNumber) {
                const stepElement = document.getElementById(`step${stepNumber}`);
                if (stepElement) {
                    stepElement.classList.remove('active', 'processing');
                    stepElement.classList.add('completed');
                }
            }

            // Show step as processing (blinking)
            markStepProcessing(stepNumber) {
                const stepElement = document.getElementById(`step${stepNumber}`);
                if (stepElement) {
                    stepElement.classList.remove('active', 'completed');
                    stepElement.classList.add('processing');
                }
            }

            // Desktop mode: Direct API call to configured AI provider
            async generateTestCasesDesktop(figmaData) {
                try {
                    const aiConfig = this.getAIConfig();
                    const prototypeData = this.extractPrototypeData(figmaData);
                    const prompt = this.createMistralPrompt(prototypeData);
                    
                    // Construct API endpoint based on configuration
                    let apiEndpoint = `${aiConfig.apiUrl.replace(/\/$/, '')}/v1/chat/completions`;
                    
                    const response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${aiConfig.apiKey}`
                        },
                        body: JSON.stringify({
                            model: aiConfig.model,
                            messages: [
                                {
                                    role: 'user',
                                    content: prompt
                                }
                            ],
                            max_tokens: 4000,
                            temperature: 0.3
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(`AI API Error ${response.status}: ${errorData.message || response.statusText}`);
                    }

                    const result = await response.json();
                    
                    if (!result.choices || !result.choices[0] || !result.choices[0].message) {
                        throw new Error('Invalid response from AI provider');
                    }

                    return {
                        success: true,
                        testCases: result.choices[0].message.content
                    };
                } catch (error) {
                    console.error('Desktop test case generation error:', error);
                    return {
                        success: false,
                        message: error.message || 'Failed to generate test cases in desktop mode'
                    };
                }
            }

            updateProgress(percentage, text, step = null) {
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                const progressPercentage = document.getElementById('progressPercentage');
                
                progressFill.style.width = percentage + '%';
                progressText.textContent = text;
                progressPercentage.textContent = Math.round(percentage) + '%';
                
                if (step) {
                    this.updateProgressSteps(step);
                }
            }

            // Prompt Display Management
            togglePromptDisplay() {
                const promptContent = document.getElementById('promptContent');
                if (promptContent.style.display === 'none') {
                    promptContent.style.display = 'block';
                } else {
                    promptContent.style.display = 'none';
                }
            }

            showPromptSection(prompt) {
                const promptSection = document.getElementById('promptSection');
                const promptText = document.getElementById('promptText');
                
                promptText.value = prompt;
                promptSection.style.display = 'block';
            }

            hidePromptSection() {
                const promptSection = document.getElementById('promptSection');
                promptSection.style.display = 'none';
            }

            // Helper methods for prompt creation and prototype data extraction
            extractPrototypeData(figmaData) {
                const prototypeData = {
                    frames: [],
                    interactions: []
                };

                function traverseNode(node, parentType = '') {
                    if (node.type === 'FRAME') {
                        const frame = {
                            id: node.id,
                            name: node.name,
                            type: node.type,
                            absoluteBoundingBox: node.absoluteBoundingBox,
                            children: []
                        };

                        if (node.children) {
                            frame.children = extractTextAndInteractions(node.children);
                        }

                        if (node.interactions && node.interactions.length > 0) {
                            node.interactions.forEach((interaction) => {
                                prototypeData.interactions.push({
                                    sourceId: node.id,
                                    sourceName: node.name,
                                    trigger: interaction.trigger,
                                    actions: interaction.actions,
                                    absoluteBoundingBox: node.absoluteBoundingBox
                                });
                            });
                        }

                        prototypeData.frames.push(frame);
                    }

                    if (node.children) {
                        node.children.forEach((child) => traverseNode(child, node.type));
                    }
                }

                function extractTextAndInteractions(children) {
                    const extracted = [];
                    
                    children.forEach(child => {
                        if (child.type === 'TEXT' && child.characters) {
                            extracted.push({
                                type: 'TEXT',
                                characters: child.characters,
                                absoluteBoundingBox: child.absoluteBoundingBox
                            });
                        }
                        
                        if (child.interactions && child.interactions.length > 0) {
                            child.interactions.forEach((interaction) => {
                                prototypeData.interactions.push({
                                    sourceId: child.id,
                                    sourceName: child.name || 'Unnamed Element',
                                    trigger: interaction.trigger,
                                    actions: interaction.actions,
                                    absoluteBoundingBox: child.absoluteBoundingBox
                                });
                            });
                        }

                        if (child.children) {
                            extracted.push(...extractTextAndInteractions(child.children));
                        }
                    });

                    return extracted;
                }

                if (figmaData.document && figmaData.document.children) {
                    figmaData.document.children.forEach((page) => {
                        if (page.children) {
                            page.children.forEach((child) => traverseNode(child));
                        }
                    });
                }

                return prototypeData;
            }

            createMistralPrompt(prototypeData) {
                return `You are analyzing Figma design data to generate automated test cases for prototype interactions.

CRITICAL REQUIREMENTS:
1. Each test case MUST include ALL 6 components in this exact order:
   <Test Case Name>,CLICK/CLICK_COORDS,coordinates/text,SLEEP,duration,CHECK,expected_text

2. CORRECT Test Case Format Examples:
   Navigate from Splash to Popular,CLICK_COORDS,540,960,SLEEP,2,CHECK,POPULAR RECIPES
   Navigate from Popular to Menu,CLICK_COORDS,74,83,SLEEP,2,CHECK,EXIT
   Navigate from Menu to Favorite,CLICK,FAVORITE RECIPES,SLEEP,2,CHECK,FAVORITE RECIPES

3. Command Rules:
   - CLICK_COORDS: Use for clickable areas without text. Format: CLICK_COORDS,x,y (where x,y are POSITIVE numbers)
   - CLICK: Use for buttons/text elements. Format: CLICK,TEXT_TO_CLICK
   - SLEEP: Always use SLEEP,2 (2 seconds wait)
   - CHECK: Verify destination screen text in UPPER CASE

4. MANDATORY Coordinate Guidelines:
   - Screen size: 1080 x 1920 pixels (width x height)
   - Top-left corner is (0,0)
   - Center coordinates: (540,960)
   - Menu button coordinates: (74,83)
   - ALL COORDINATES MUST BE POSITIVE NUMBERS ONLY
   - NEVER use negative coordinates like (-1295,-134) - this is WRONG
   - Valid coordinate range: X: 0-1080, Y: 0-1920
   - Examples of CORRECT coordinates: 74,83 or 540,960 or 200,400
   - Examples of WRONG coordinates: -1295,-134 or 1131,-134 (negative numbers are invalid)

5. Navigation Flow Rules:
   - Create sequential navigation paths
   - Navigate FROM source TO destination
   - Then continue FROM that destination to next screen
   - Include back navigation using menu buttons at coordinates like 74,83

6. Text Formatting:
   - ALL text in CLICK and CHECK commands must be UPPER CASE
   - Match exact spelling from Figma data
   - No extra spaces around commas

7. Required Output:
   - Generate test cases that follow complete user journeys
   - Include forward and backward navigation
   - Each line must be a complete test case with all 6 components
   - NO comments, explanations, or additional text
   - ONLY use POSITIVE coordinate values (0-1080 for X, 0-1920 for Y)

Figma Prototype Data:
${JSON.stringify(prototypeData, null, 2)}

Generate complete test cases following the exact format above:`;
            }

            // Console Output Management
            showConsoleWindow() {
                const consoleWindow = document.getElementById('consoleWindow');
                consoleWindow.style.display = 'block';
            }

            hideConsoleWindow() {
                const consoleWindow = document.getElementById('consoleWindow');
                consoleWindow.style.display = 'none';
            }

            addConsoleOutput(message, type = 'info') {
                const consoleOutput = document.getElementById('consoleOutput');
                const timestamp = new Date().toLocaleTimeString();
                
                let color = '#00ff00'; // default green
                if (type === 'error') color = '#ff4444';
                if (type === 'warning') color = '#ffaa00';
                if (type === 'info') color = '#00aaff';
                
                const logEntry = document.createElement('div');
                logEntry.style.color = color;
                logEntry.innerHTML = `[${timestamp}] ${message}`;
                
                consoleOutput.appendChild(logEntry);
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }

            clearConsoleOutput() {
                const consoleOutput = document.getElementById('consoleOutput');
                consoleOutput.innerHTML = '<div style="color: #888;">Test Executor Console - Cleared</div>';
            }

            // Auto-run testexecutor.bat functionality
            async runTestExecutor() {
                if (window.electronAPI) {
                    this.showConsoleWindow();
                    this.addConsoleOutput('Starting Test Executor...', 'info');
                    
                    try {
                        // For desktop version, run c:\testexecutor.bat
                        const result = await window.electronAPI.runExecutable('c:\\testexecutor.bat');
                        this.addConsoleOutput('Test Executor launched successfully', 'info');
                        
                        // Monitor output if available
                        if (result.output) {
                            result.output.split('\n').forEach(line => {
                                if (line.trim()) {
                                    this.addConsoleOutput(line, 'info');
                                }
                            });
                        }
                        
                    } catch (error) {
                        this.addConsoleOutput(`Error running Test Executor: ${error.message}`, 'error');
                        this.showStatus('Failed to run Test Executor: ' + error.message, 'error');
                        throw error;
                    }
                } else {
                    throw new Error('Test Executor can only run in desktop mode');
                }
            }

            // AI Test Case Generator methods
            async generateTestCases() {
                const generateButton = document.getElementById('generateTestCasesButton');
                generateButton.disabled = true;
                generateButton.textContent = 'Generating Test Cases...';
                
                this.showStatus('Fetching Figma file data for AI analysis...', 'info');
                this.showProgress();
                this.updateProgress(10, 'Loading Figma file data...');

                try {
                    // Step 1: Get the full Figma file data including prototypes
                    const fileData = await this.makeApiRequest(`/files/${this.fileId}?geometry=paths`);
                    this.updateProgress(30, 'Analyzing prototype interactions...');

                    // Step 2: Create and display the prompt
                    const prototypeData = this.extractPrototypeData(fileData);
                    const prompt = this.createMistralPrompt(prototypeData);
                    this.showPromptSection(prompt);

                    // Step 3: Send to Mistral AI for test case generation
                    this.updateProgress(60, 'Sending to Mistral AI...');
                    let result;
                    
                    if (window.electronAPI) {
                        // Desktop mode - direct API call to Mistral
                        result = await this.generateTestCasesDesktop(fileData);
                    } else {
                        // Web mode - use Express server
                        const response = await fetch('/api/generate-test-cases', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ figmaData: fileData, mistralApiKey: this.mistralKey })
                        });

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({}));
                            throw new Error(`AI Error ${response.status}: ${errorData.message || response.statusText}`);
                        }

                        this.updateProgress(80, 'Processing AI response...');
                        result = await response.json();
                    }
                    
                    if (result.success && result.testCases) {
                        this.updateProgress(100, 'Test cases generated successfully!');
                        this.displayTestCases(result.testCases);
                        this.showStatus(`Generated ${result.testCases.split('\n').filter(line => line.trim()).length} test cases`, 'success');
                    } else {
                        throw new Error(result.message || 'Failed to generate test cases');
                    }

                } catch (error) {
                    this.showStatus(`Error generating test cases: ${error.message}`, 'error');
                    console.error('Test case generation error:', error);
                } finally {
                    this.hideProgress();
                    generateButton.disabled = false;
                    generateButton.textContent = 'Generate Test Cases from Figma';
                }
            }

            displayTestCases(testCases) {
                const outputDiv = document.getElementById('testCaseOutput');
                const textArea = document.getElementById('testCaseText');
                
                textArea.value = testCases;
                outputDiv.style.display = 'block';
                this.generatedTestCases = testCases;
            }

            downloadTestCases() {
                if (!this.generatedTestCases) {
                    this.showStatus('No test cases to download', 'error');
                    return;
                }

                try {
                    if (window.electronAPI) {
                        // Desktop version - use Electron's file save dialog
                        this.saveTestCasesDesktop();
                    } else {
                        // Web version - use browser download
                        this.saveTestCasesWeb();
                    }
                } catch (error) {
                    this.showStatus(`Error downloading test cases: ${error.message}`, 'error');
                }
            }

            saveTestCasesWeb() {
                const blob = new Blob([this.generatedTestCases], { type: 'text/plain' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'testcases.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                this.showStatus('Test cases downloaded as testcases.txt', 'success');
            }

            async saveTestCasesDesktop() {
                try {
                    // Save directly to C:\AutoExecutor\testcases.txt without dialog
                    const filePath = `C:\\AutoExecutor\\testcases.txt`;
                    const buffer = new TextEncoder().encode(this.generatedTestCases);
                    const result = await window.electronAPI.saveFile(filePath, Array.from(buffer));
                    
                    if (result.success) {
                        this.showStatus(`Test cases saved to: ${filePath}`, 'success');
                    } else {
                        this.showStatus(`Error saving file: ${result.message}`, 'error');
                    }
                } catch (error) {
                    this.showStatus(`Error saving test cases: ${error.message}`, 'error');
                }
            }

            // Exe runner methods
            async selectExeFile() {
                try {
                    if (window.electronAPI) {
                        const exePath = await window.electronAPI.selectExeFile();
                        if (exePath) {
                            this.selectedExePath = exePath;
                            document.getElementById('selectedExePath').textContent = `Selected: ${exePath}`;
                            document.getElementById('runExeButton').disabled = false;
                            this.showStatus('Executable file selected successfully', 'success');
                        }
                    } else {
                        this.showStatus('This feature only works in the desktop app. Please run with Electron.', 'error');
                    }
                } catch (error) {
                    this.showStatus(`Error selecting file: ${error.message}`, 'error');
                }
            }

            async runSelectedExe() {
                if (!this.selectedExePath) {
                    this.showStatus('Please select an executable file first', 'error');
                    return;
                }

                try {
                    this.showStatus('Starting executable...', 'info');
                    const result = await window.electronAPI.executeExe(this.selectedExePath);
                    
                    if (result.success) {
                        this.showStatus(`Executable started successfully (PID: ${result.pid})`, 'success');
                    } else {
                        this.showStatus(`Failed to start executable: ${result.message}`, 'error');
                    }
                } catch (error) {
                    this.showStatus(`Error running executable: ${error.message}`, 'error');
                }
            }

            showStatus(message, type = 'info') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
                statusEl.style.display = 'block';
            }

            hideStatus() {
                document.getElementById('status').style.display = 'none';
            }

            showProgress() {
                document.getElementById('progress').style.display = 'block';
            }

            hideProgress() {
                document.getElementById('progress').style.display = 'none';
            }

            updateProgress(percentage, text) {
                document.getElementById('progressFill').style.width = `${percentage}%`;
                document.getElementById('progressText').textContent = text;
            }

            showFrameList() {
                document.getElementById('frameList').style.display = 'block';
            }

            addFrameToList(frame) {
                const frameList = document.getElementById('frameList');
                const frameItem = document.createElement('div');
                frameItem.className = 'frame-item';
                frameItem.id = `frame-${frame.id}`;
                frameItem.innerHTML = `
                    <span class="frame-name">${frame.name}</span>
                    <span class="frame-status" id="status-${frame.id}">Pending</span>
                `;
                frameList.appendChild(frameItem);
            }

            updateFrameStatus(frameId, status, text) {
                const statusEl = document.getElementById(`status-${frameId}`);
                if (statusEl) {
                    statusEl.textContent = text;
                    statusEl.className = `frame-status ${status}`;
                }
            }

            async makeApiRequest(endpoint) {
                const response = await fetch(`${this.baseUrl}${endpoint}`, {
                    headers: {
                        'X-Figma-Token': this.apiToken
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`API Error ${response.status}: ${errorData.message || response.statusText}`);
                }

                return await response.json();
            }

            async getFrames() {
                this.showStatus('Fetching file structure...', 'info');
                this.updateProgress(10, 'Loading file data...');

                try {
                    const fileData = await this.makeApiRequest(`/files/${this.fileId}`);
                    const frames = [];

                    // Traverse the document tree to find all frames
                    const traverseNode = (node, pageName = '') => {
                        if (node.type === 'CANVAS') {
                            pageName = node.name;
                        }
                        
                        if (node.type === 'FRAME') {
                            const frame = {
                                id: node.id,
                                name: node.name,
                                page: pageName
                            };
                            frames.push(frame);
                            console.log('Found frame:', frame);
                        }

                        if (node.children) {
                            node.children.forEach(child => traverseNode(child, pageName));
                        }
                    };

                    fileData.document.children.forEach(page => traverseNode(page));

                    if (frames.length === 0) {
                        throw new Error('No frames found in the Figma file');
                    }

                    this.frames = frames;
                    this.showStatus(`Found ${frames.length} frames`, 'success');
                    this.updateProgress(25, `Found ${frames.length} frames`);
                    
                    return frames;
                } catch (error) {
                    this.showStatus(`Error fetching frames: ${error.message}`, 'error');
                    throw error;
                }
            }

            async exportFrames(frameIds) {
                this.updateProgress(30, 'Requesting frame exports...');

                try {
                    const params = new URLSearchParams({
                        ids: frameIds.join(','),
                        format: 'png',
                        scale: '2'
                    });

                    const exportData = await this.makeApiRequest(`/images/${this.fileId}?${params}`);
                    
                    if (!exportData.images || Object.keys(exportData.images).length === 0) {
                        throw new Error('No export URLs received from Figma API');
                    }

                    // Debug: Log which frames got URLs and which didn't
                    console.log('Export data received:', exportData);
                    frameIds.forEach(frameId => {
                        if (!exportData.images[frameId]) {
                            console.warn(`No export URL for frame ID: ${frameId}`);
                        }
                    });

                    // Check for any API errors in the response
                    if (exportData.err) {
                        console.error('Figma API returned error:', exportData.err);
                    }

                    this.updateProgress(50, 'Export URLs generated');
                    return exportData.images;
                } catch (error) {
                    this.showStatus(`Error exporting frames: ${error.message}`, 'error');
                    throw error;
                }
            }

            async downloadImage(frameId, imageUrl, frameName) {
                this.updateFrameStatus(frameId, 'downloading', 'Downloading...');
                
                try {
                    const response = await fetch(imageUrl);
                    if (!response.ok) {
                        throw new Error(`Download failed: ${response.statusText}`);
                    }

                    const blob = await response.blob();
                    
                    if (window.electronAPI) {
                        // Desktop mode - save directly to C:\AutoExecutor\screenshots
                        const arrayBuffer = await blob.arrayBuffer();
                        const buffer = Array.from(new Uint8Array(arrayBuffer));
                        const fileName = `${frameName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.png`;
                        const filePath = `C:\\AutoExecutor\\screenshots\\${fileName}`;
                        
                        const result = await window.electronAPI.saveFile(filePath, buffer);
                        if (result.success) {
                            this.updateFrameStatus(frameId, 'completed', 'Saved');
                            this.exportedCount++;
                        } else {
                            throw new Error(`Failed to save: ${result.message}`);
                        }
                    } else {
                        // Web mode - use browser download
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${frameName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        
                        this.updateFrameStatus(frameId, 'completed', 'Downloaded');
                        this.exportedCount++;
                    }
                    
                } catch (error) {
                    this.updateFrameStatus(frameId, 'failed', 'Failed');
                    console.error(`Failed to download frame ${frameName}:`, error);
                }
            }

            async exportAllFrames() {
                const exportButton = document.getElementById('exportButton');
                exportButton.disabled = true;
                exportButton.textContent = 'Exporting...';
                
                this.hideStatus();
                this.showProgress();
                this.exportedCount = 0;

                try {
                    // Step 1: Get all frames
                    const frames = await this.getFrames();
                    
                    // Step 2: Show frame list
                    this.showFrameList();
                    frames.forEach(frame => this.addFrameToList(frame));
                    
                    // Step 3: Export frames (batch process in chunks of 50)
                    const chunkSize = 50;
                    const chunks = [];
                    for (let i = 0; i < frames.length; i += chunkSize) {
                        chunks.push(frames.slice(i, i + chunkSize));
                    }

                    for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                        const chunk = chunks[chunkIndex];
                        const frameIds = chunk.map(f => f.id);
                        
                        this.updateProgress(
                            50 + (chunkIndex / chunks.length) * 30, 
                            `Processing batch ${chunkIndex + 1} of ${chunks.length}...`
                        );
                        
                        const imageUrls = await this.exportFrames(frameIds);
                        
                        // Step 4: Download all images
                        const downloadPromises = chunk.map(frame => {
                            const imageUrl = imageUrls[frame.id];
                            if (imageUrl) {
                                return this.downloadImage(frame.id, imageUrl, frame.name);
                            } else {
                                console.error(`Failed to download frame ${frame.name}:`, {
                                    frameId: frame.id,
                                    frameName: frame.name,
                                    reason: 'No export URL received from Figma API',
                                    availableIds: Object.keys(imageUrls)
                                });
                                this.updateFrameStatus(frame.id, 'failed', 'No URL');
                                return Promise.resolve();
                            }
                        });
                        
                        await Promise.all(downloadPromises);
                        
                        // Rate limiting between batches
                        if (chunkIndex < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }

                    this.updateProgress(100, 'Export completed!');
                    this.showStatus(`Successfully exported ${this.exportedCount} of ${frames.length} frames`, 'success');
                    
                } catch (error) {
                    console.error('Export failed:', error);
                    this.showStatus(`Export failed: ${error.message}`, 'error');
                } finally {
                    exportButton.disabled = false;
                    exportButton.textContent = 'Export All Frames';
                    
                    // Hide progress after 3 seconds
                    setTimeout(() => {
                        this.hideProgress();
                    }, 3000);
                }
            }
        }

        // Toggle description functionality
        function toggleDescription() {
            const content = document.getElementById('descriptionContent');
            const toggle = document.getElementById('descriptionToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        // Toggle individual operations functionality
        function toggleIndividualOperations() {
            const content = document.getElementById('individualContent');
            const toggle = document.getElementById('individualToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        // Toggle manual execution functionality
        function toggleManualExecution() {
            const content = document.getElementById('manualContent');
            const toggle = document.getElementById('manualToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        // Toggle AI configuration functionality
        function toggleAIConfig() {
            const content = document.getElementById('aiConfigContent');
            const toggle = document.getElementById('aiConfigToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        // Initialize the exporter when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new FigmaExporter();
            
            // Initialize description as collapsed
            document.getElementById('descriptionContent').style.display = 'none';
            document.getElementById('descriptionToggle').textContent = '‚ñ∂';
            
            // Initialize individual operations as collapsed
            document.getElementById('individualContent').style.display = 'none';
            document.getElementById('individualToggle').textContent = '‚ñ∂';
            
            // Initialize manual execution as collapsed
            document.getElementById('manualContent').style.display = 'none';
            document.getElementById('manualToggle').textContent = '‚ñ∂';
            
            // Initialize AI config as collapsed
            document.getElementById('aiConfigContent').style.display = 'none';
            document.getElementById('aiConfigToggle').textContent = '‚ñ∂';
        });
    </script>
</body>
</html>
