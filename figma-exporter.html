<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DA Auto Test Generator from Figma</title>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' https://api.figma.com https://api.mistral.ai https://s3-alpha-sig.figma.com https://figma-alpha-api.s3.us-west-2.amazonaws.com https://*.amazonaws.com; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
            max-width: 1200px;
            width: 100%;
        }

        /* Responsive layout for mobile devices */
        @media (max-width: 768px) {
            .two-column-layout {
                flex-direction: column !important;
                gap: 20px !important;
            }
            
            .container {
                padding: 20px !important;
                max-width: 100% !important;
            }
            
            body {
                padding: 10px !important;
            }

            .header h1 {
                font-size: 24px !important;
            }

            .header p {
                font-size: 14px !important;
            }
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 28px;
            margin-bottom: 10px;
        }

        .header p {
            color: #7f8c8d;
            font-size: 16px;
        }

        .credentials {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .credential-item {
            margin-bottom: 15px;
        }

        .credential-item:last-child {
            margin-bottom: 0;
        }

        .credential-item label {
            display: block;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .credential-item input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            background: white;
            transition: border-color 0.2s;
        }

        .credential-item input:focus {
            outline: none;
            border-color: #667eea;
        }

        .export-button {
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 16px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 20px;
        }

        .export-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .export-button:active {
            transform: translateY(0);
        }

        .export-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .unified-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.4);
        }

        .unified-button:disabled {
            transform: none;
            box-shadow: none;
        }

        .status {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-size: 14px;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .progress {
            margin-top: 20px;
            display: none;
        }

        .progress-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            position: relative;
        }

        .progress-step {
            flex: 1;
            text-align: center;
            position: relative;
            padding: 10px 5px;
        }

        .progress-step::after {
            content: '';
            position: absolute;
            top: 25px;
            right: -50%;
            width: 100%;
            height: 2px;
            background: #e9ecef;
            z-index: 1;
        }

        .progress-step:last-child::after {
            display: none;
        }

        .progress-step.active::after {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .step-icon {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #e9ecef;
            color: #6c757d;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 15px;
            font-weight: 900;
            position: relative;
            z-index: 2;
            transition: all 0.3s ease;
            font-size: 32px;
            font-family: Arial, sans-serif;
        }

        .progress-step.active .step-icon {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            transform: scale(1.15);
            animation: activeBlink 1s infinite, pulse 2s infinite;
            border: 3px solid #ff6b35;
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
        }

        .progress-step.processing .step-icon {
            background: linear-gradient(135deg, #ffc107 0%, #ff8f00 100%);
            color: white;
            transform: scale(1.1);
            animation: processingBlink 0.8s infinite;
            border: 3px solid #ffc107;
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.4);
        }

        @keyframes activeBlink {
            0%, 50% {
                opacity: 1;
                background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            }
            25%, 75% {
                opacity: 0.7;
                background: linear-gradient(135deg, #f7931e 0%, #ff6b35 100%);
            }
        }

        @keyframes processingBlink {
            0% {
                opacity: 1;
                transform: scale(1.1);
            }
            50% {
                opacity: 0.6;
                transform: scale(1.05);
            }
            100% {
                opacity: 1;
                transform: scale(1.1);
            }
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 107, 53, 0.7);
            }
            70% {
                box-shadow: 0 0 0 15px rgba(255, 107, 53, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 107, 53, 0);
            }
        }

        .progress-step.completed .step-icon {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: 3px solid #28a745;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .progress-step.completed .step-icon::after {
            content: '✓';
            position: absolute;
            font-size: 28px;
            font-weight: bold;
            color: #000000;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }



        .step-title {
            font-size: 16px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 6px;
        }

        .step-description {
            font-size: 12px;
            color: #6c757d;
            font-weight: 500;
        }

        .progress-step.active .step-title {
            color: #667eea;
            font-weight: bold;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 5px #667eea;
            }
            to {
                text-shadow: 0 0 10px #667eea, 0 0 15px #667eea;
            }
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #e9ecef;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 6px;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background-image: 
                linear-gradient(
                    -45deg,
                    rgba(255, 255, 255, .2) 25%,
                    transparent 25%,
                    transparent 50%,
                    rgba(255, 255, 255, .2) 50%,
                    rgba(255, 255, 255, .2) 75%,
                    transparent 75%,
                    transparent
                );
            background-size: 50px 50px;
            animation: move 2s linear infinite;
        }

        @keyframes move {
            0% {
                background-position: 0 0;
            }
            100% {
                background-position: 50px 50px;
            }
        }

        .progress-text {
            text-align: center;
            font-size: 14px;
            color: #495057;
            font-weight: 500;
        }

        .progress-percentage {
            text-align: center;
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
        }

        .frame-list {
            margin-top: 20px;
            display: none;
        }

        .frame-item {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .frame-name {
            font-weight: 500;
            color: #2c3e50;
        }

        .frame-status {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            background: #e9ecef;
            color: #6c757d;
        }

        .frame-status.downloading {
            background: #fff3cd;
            color: #856404;
        }

        .frame-status.completed {
            background: #d4edda;
            color: #155724;
        }

        .frame-status.failed {
            background: #f8d7da;
            color: #721c24;
        }

        /* Workflow Progress Animation Styles - No background change for main section */
        .workflow-progress-active {
            /* Keep original styling - no background changes */
        }

        /* Default white background for workflow steps - Override existing styles */
        #descriptionContent > div {
            background: white !important;
            border-left: 4px solid #e0e0e0 !important;
            padding: 12px;
            margin: 5px 0;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        /* Force override any existing background styles */
        #descriptionContent > div[style*="background"] {
            background: white !important;
        }

        .workflow-step-active {
            animation: workflowStepBlink 1s infinite, workflowStepPulse 2s infinite;
            background: #ffff00 !important;
            border-left: 4px solid #ffdd00 !important;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(255, 221, 0, 0.6);
        }

        /* Force override existing background for active state */
        .workflow-step-active[style*="background"] {
            background: #ffff00 !important;
        }

        .workflow-step-active strong {
            color: #cc8800 !important;
            animation: workflowStepGlow 1.5s ease-in-out infinite alternate;
            text-shadow: 0 0 5px rgba(255, 221, 0, 0.8);
        }

        .workflow-step-active span {
            color: #996600 !important;
        }

        .workflow-step-completed {
            position: relative;
            background: #90EE90 !important;
            border-left: 4px solid #28a745 !important;
        }

        /* Force override existing background for completed state */
        .workflow-step-completed[style*="background"] {
            background: #90EE90 !important;
        }

        .workflow-step-completed::after {
            content: '✓';
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 24px;
            font-weight: bold;
            color: #28a745;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        .workflow-step-completed strong {
            color: #28a745 !important;
        }

        .workflow-step-completed span {
            color: #155724 !important;
        }

        @keyframes workflowStepBlink {
            0%, 50% {
                opacity: 1;
                background: #ffff00 !important;
            }
            25%, 75% {
                opacity: 0.9;
                background: #ffdd00 !important;
            }
        }

        @keyframes workflowStepPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 221, 0, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 221, 0, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 221, 0, 0);
            }
        }

        @keyframes workflowStepGlow {
            from {
                text-shadow: 0 0 5px rgba(255, 221, 0, 0.8);
            }
            to {
                text-shadow: 0 0 10px rgba(255, 221, 0, 0.8), 0 0 15px rgba(255, 221, 0, 0.8);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px 25px; border-radius: 12px; margin-bottom: 25px; box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2);">
            <h1 style="color: #ffffff; margin-bottom: 12px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);">DA: Auto Test Generator from Figma using AI & auto Execution on Device</h1>
            <p style="color: #f8f9fa; margin-bottom: 0; opacity: 0.95;">Generate and validate test case & auto execute on real device</p>
        </div>

        <!-- Two Column Layout -->
        <div class="two-column-layout" style="display: flex; gap: 30px; margin-bottom: 30px;">
            <!-- Left Column: How Application Works -->
            <div style="flex: 1; min-width: 0;">
                <div class="description-section" style="background: #e8f4fd; border-radius: 8px; padding: 15px 20px; border-left: 4px solid #007bff;">
                    <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleDescription()">
                        <h3 style="color: #0056b3; margin: 0; font-size: 18px;">WORKFLOW PROGRESS</h3>
                        <span id="descriptionToggle" style="color: #007bff; font-size: 20px; font-weight: bold;">▼</span>
                    </div>
                    <div id="descriptionContent" style="display: block; margin-top: 15px; color: #495057; line-height: 1.6;">
                        <div style="margin-bottom: 12px; padding: 12px; background: rgba(0,123,255,0.1); border-radius: 6px; border-left: 4px solid #007bff;">
                            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                                <span style="background: #007bff; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; margin-right: 10px;">1</span>
                                <strong style="color: #0056b3;">🔗 Figma Connect</strong>
                            </div>
                            <span style="color: #6c757d; font-size: 12px; margin-left: 34px; display: block;">API Token → Extract Design Frames & Prototypes</span>
                        </div>
                        <div style="margin-bottom: 12px; padding: 12px; background: rgba(220,53,69,0.1); border-radius: 6px; border-left: 4px solid #dc3545;">
                            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                                <span style="background: #dc3545; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; margin-right: 10px;">2</span>
                                <strong style="color: #dc3545;">📊 Process Figma data</strong>
                            </div>
                            <span style="color: #6c757d; font-size: 12px; margin-left: 34px; display: block;">Parse Elements → Identify Clickable Areas & Navigation</span>
                        </div>
                        <div style="margin-bottom: 12px; padding: 12px; background: rgba(255,193,7,0.1); border-radius: 6px; border-left: 4px solid #ffc107;">
                            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                                <span style="background: #ffc107; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; margin-right: 10px;">3</span>
                                <strong style="color: #ffc107;">🤖 AI Analysis</strong>
                            </div>
                            <span style="color: #6c757d; font-size: 12px; margin-left: 34px; display: block;">Send Data → AI Models → Intelligent Test Generation</span>
                        </div>
                        <div style="margin-bottom: 12px; padding: 12px; background: rgba(40,167,69,0.1); border-radius: 6px; border-left: 4px solid #28a745;">
                            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                                <span style="background: #28a745; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; margin-right: 10px;">4</span>
                                <strong style="color: #28a745;">🧪 Generate test case</strong>
                            </div>
                            <span style="color: #6c757d; font-size: 12px; margin-left: 34px; display: block;">Create Scripts → Coordinates + Actions + Validation</span>
                        </div>
                        <div style="margin-bottom: 0px; padding: 12px; background: rgba(102,126,234,0.1); border-radius: 6px; border-left: 4px solid #667eea;">
                            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                                <span style="background: #667eea; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; margin-right: 10px;">5</span>
                                <strong style="color: #667eea;">⚡ Auto Execute</strong>
                            </div>
                            <span style="color: #6c757d; font-size: 12px; margin-left: 34px; display: block;">Download → Launch TestExecutor → Run on Device</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Steps & Execution -->
            <div style="flex: 1; min-width: 0;">
                <!-- Figma Resources Section -->
                <div class="figma-resources-section" style="margin-bottom: 20px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                    <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px 20px;" onclick="toggleFigmaResources()">
                        <h3 style="color: #2c3e50; margin: 0; font-size: 16px;">🎨 Figma Resources</h3>
                        <span id="figmaResourcesToggle" style="color: #2c3e50; font-size: 20px; font-weight: bold;">▶</span>
                    </div>
                    <div id="figmaResourcesContent" style="display: none; padding: 0 20px 20px 20px;">
                        <div class="credential-item">
                            <label for="apiToken">Figma API Token</label>
                            <input type="password" id="apiToken" value="figd_2nGk49M9ujxccf01lNpgv3gGfqKaRQ74Q0jBhzn1" style="background: #fff; border: 1px solid #ced4da; font-family: monospace;">
                        </div>
                        <div class="credential-item">
                            <label for="fileId">Figma File ID</label>
                            <input type="text" id="fileId" value="2k2t7ZfG09nLyjM4viAGHP" style="background: #fff; border: 1px solid #ced4da; font-family: monospace;">
                        </div>
                    </div>
                </div>

                <!-- AI Configuration Section -->
                <div class="ai-config-section" style="margin-bottom: 20px; background: #fff3cd; border-radius: 8px; border: 1px solid #ffeaa7;">
                    <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px 20px;" onclick="toggleAIConfig()">
                        <h3 style="color: #856404; margin: 0; font-size: 16px;">⚙️ AI Configuration</h3>
                        <span id="aiConfigToggle" style="color: #856404; font-size: 20px; font-weight: bold;">▶</span>
                    </div>
                    <div id="aiConfigContent" style="display: none; padding: 0 20px 20px 20px;">
                        <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 193, 7, 0.1); border-radius: 6px; border-left: 4px solid #ffc107;">
                            <div style="font-size: 13px; color: #856404; font-weight: 600; margin-bottom: 5px;">💡 Configuration Options</div>
                            <div style="font-size: 12px; color: #6c757d;">
                                • <strong>Mistral AI:</strong> https://api.mistral.ai (Default)<br>
                                • <strong>Local Ollama:</strong> http://localhost:11434<br>
                                • <strong>Local LM Studio:</strong> http://localhost:1234<br>
                                • <strong>OpenAI:</strong> https://api.openai.com<br>
                                • <strong>Groq:</strong> https://api.groq.com<br>
                                • <strong>Custom Local:</strong> Your own deployment URL
                            </div>
                        </div>
                        <div class="credential-item">
                            <label for="aiApiUrl">AI API Base URL</label>
                            <input type="text" id="aiApiUrl" value="https://api.mistral.ai" style="background: #fff; border: 1px solid #ced4da; font-family: monospace;" placeholder="https://api.mistral.ai">
                        </div>
                        <div class="credential-item">
                            <label for="aiApiKey">AI API Key</label>
                            <input type="password" id="aiApiKey" value="gmEWLMGdvQ4loD8fJ1bO70eknyEgA35x" style="background: #fff; border: 1px solid #ced4da; font-family: monospace;" placeholder="Your AI API key">
                        </div>
                        <div class="credential-item" style="margin-bottom: 0;">
                            <label for="aiModel">AI Model</label>
                            <input type="text" id="aiModel" value="mistral-large-latest" style="background: #fff; border: 1px solid #ced4da; font-family: monospace;" placeholder="mistral-large-latest">
                            <div style="font-size: 11px; color: #6c757d; margin-top: 5px;">
                                Examples: mistral-large-latest, llama3-8b-8192, gpt-4, claude-3-haiku-20240307
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Mistral Prompt Section - Moved above the button -->
                <div class="mistral-prompt-section" id="mistralPromptSection" style="margin-bottom: 20px; background: #e3f2fd; border-radius: 8px; border: 1px solid #90caf9;">
                    <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px 20px;" onclick="toggleMistralPrompt()">
                        <h4 style="color: #1976d2; margin: 0; font-size: 16px;">📝 AI Prompt (Fixed Template)</h4>
                        <span id="mistralPromptToggle" style="color: #1976d2; font-size: 20px; font-weight: bold;">▶</span>
                    </div>
                    <div id="mistralPromptContent" style="display: none; padding: 0 20px 20px 20px;">
                        <textarea id="mistralPromptText" readonly style="width: 100%; height: 300px; padding: 15px; border: 1px solid #90caf9; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 11px; background: #f3f9ff; resize: vertical;">You are a QA automation expert specializing in mobile app testing and test case generation. You are analyzing Figma design data to generate automated test cases for prototype interactions with precision and thoroughness.

CRITICAL REQUIREMENTS:
1. Each test case MUST include ALL 6 components in this exact order:
   <Test Case Name>,CLICK/CLICK_COORDS,coordinates/text,SLEEP,duration,CHECK,expected_text

2. CORRECT Test Case Format Examples:
   Navigate from Splash to Popular,CLICK_COORDS,540,960,SLEEP,2,CHECK,POPULAR RECIPES
   Navigate from Popular to Menu,CLICK_COORDS,74,83,SLEEP,2,CHECK,EXIT
   Navigate from Menu to Favorite,CLICK,FAVORITE RECIPES,SLEEP,2,CHECK,FAVORITE RECIPES

3. Command Rules:
   - CLICK_COORDS: Use for clickable areas without text. Format: CLICK_COORDS,x,y (where x,y are POSITIVE numbers)
   - CLICK: Use for buttons/text elements. Format: CLICK,TEXT_TO_CLICK
   - SLEEP: Always use SLEEP,2 (2 seconds wait)
   - CHECK: Verify destination screen text in UPPER CASE

4. MANDATORY Coordinate Guidelines:
   - All coordinates must be POSITIVE numbers (no negative values)
   - X coordinate: 0 to screen width (typically 1080)
   - Y coordinate: 0 to screen height (typically 1920)
   - Use EXACT coordinates from node.absoluteBoundingBox

5. Navigation Flow Analysis:
   - Identify ALL clickable elements with their exact coordinates
   - Map destination screens for each interaction
   - Create comprehensive test coverage

6. Output Format:
   - Start each test case on a new line
   - Use EXACT comma separation (no spaces after commas)
   - Keep destination text in UPPER CASE for CHECK commands

Generate complete test cases following the exact format above:</textarea>
                        <div style="margin-top: 10px; font-size: 12px; color: #555;">
                            <strong>Note:</strong> This is the template sent to Mistral AI to generate test cases.
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <!-- Professional Separator -->
        <div style="margin: 30px 0; border-top: 2px solid #e9ecef; position: relative;">
            <div style="position: absolute; top: -12px; left: 50%; transform: translateX(-50%); background: white; padding: 0 20px; color: #6c757d; font-weight: 600; font-size: 14px;">MAIN ACTION</div>
        </div>

        <!-- Full Width Generate Button -->
        <div style="margin-bottom: 30px; width: 100%;">
            <button class="export-button unified-button" id="unifiedButtonFullWidth" style="background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%); font-size: 20px; font-weight: bold; padding: 24px 32px; transition: all 0.3s ease; width: 100%; border-radius: 12px; border: none; color: white; cursor: pointer; box-shadow: 0 6px 20px rgba(255, 193, 7, 0.3);" onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 10px 30px rgba(255, 193, 7, 0.4)'" onmouseout="this.style.transform='translateY(0px)'; this.style.boxShadow='0 6px 20px rgba(255, 193, 7, 0.3)'">🚀 Generate Test Cases with AI & Auto Execute using Test Executor</button>
        </div>

        <!-- Progress Separator -->
        <div style="margin: 40px 0; border-top: 2px solid #e9ecef; position: relative;">
            <div style="position: absolute; top: -12px; left: 50%; transform: translateX(-50%); background: white; padding: 0 20px; color: #6c757d; font-weight: 600; font-size: 14px;">WORKFLOW PROGRESS</div>
        </div>





        <div class="status" id="status"></div>

        <div class="progress" id="progress">
            <!-- Progress Steps -->
            <div class="progress-steps" id="progressSteps">
                <div class="progress-step" id="step1">
                    <div class="step-icon">1</div>
                    <div class="step-title">Connect</div>
                    <div class="step-description">Figma API</div>
                </div>
                <div class="progress-step" id="step2">
                    <div class="step-icon">2</div>
                    <div class="step-title">Extract</div>
                    <div class="step-description">Design Data</div>
                </div>
                <div class="progress-step" id="step3">
                    <div class="step-icon">3</div>
                    <div class="step-title">AI Analysis</div>
                    <div class="step-description">Mistral AI</div>
                </div>
                <div class="progress-step" id="step4">
                    <div class="step-icon">4</div>
                    <div class="step-title">Generate</div>
                    <div class="step-description">Test Cases</div>
                </div>
                <div class="progress-step" id="step5">
                    <div class="step-icon">5</div>
                    <div class="step-title">Execute</div>
                    <div class="step-description">Auto Run</div>
                </div>
            </div>
            
            <!-- Progress Bar -->
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Preparing export...</div>
            <div class="progress-percentage" id="progressPercentage">0%</div>
        </div>

        <!-- Figma data sent to AI Section -->
        <div class="mistral-json-section" id="mistralJsonSection" style="display: none; margin-bottom: 20px; background: #fff3e0; border-radius: 8px; border: 1px solid #ffb74d;">
            <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px 20px;" onclick="toggleMistralJson()">
                <h4 style="color: #f57c00; margin: 0; font-size: 16px;">📊 Figma data sent to AI</h4>
                <span id="mistralJsonToggle" style="color: #f57c00; font-size: 20px; font-weight: bold;">▶</span>
            </div>
            <div id="mistralJsonContent" style="display: none; padding: 0 20px 20px 20px;">
                <textarea id="mistralJsonText" readonly style="width: 100%; height: 400px; padding: 15px; border: 1px solid #ffb74d; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 10px; background: #fffdf7; resize: vertical;"></textarea>
                <div style="margin-top: 10px; font-size: 12px; color: #555;">
                    <strong>Note:</strong> This is the processed Figma prototype data that gets sent to Mistral AI along with the prompt.
                </div>
            </div>
        </div>

        <!-- Generated Test Cases Section - Full Width -->
        <div class="test-cases-section" id="testCasesSection" style="display: none; margin-bottom: 20px; background: #e8f5e8; border-radius: 8px; border: 1px solid #4caf50; width: 100%; max-width: 100%;">
            <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px 20px;" onclick="toggleTestCases()">
                <h4 style="color: #2e7d32; margin: 0; font-size: 18px; font-weight: 700;">🧪 Generated Test Cases with AI</h4>
                <span id="testCasesToggle" style="color: #2e7d32; font-size: 20px; font-weight: bold;">▶</span>
            </div>
            <div id="testCasesContent" style="display: none; padding: 0 20px 20px 20px;">
                <textarea id="testCasesText" readonly style="width: 100%; height: 500px; padding: 15px; border: 1px solid #4caf50; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 12px; background: #f9fff9; resize: vertical; max-width: 100%;"></textarea>
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button id="downloadTestCasesExpanded" style="padding: 10px 20px; background: #4caf50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">📥 Download testcases.txt</button>
                    <button id="copyTestCases" style="padding: 10px 20px; background: #2196f3; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">📋 Copy to Clipboard</button>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #555;">
                    <strong>Note:</strong> Test cases generated by Mistral AI. Download as .txt file or copy to clipboard for manual use.
                </div>
            </div>
        </div>

        <!-- Figma Gui frame for test case Section -->
        <div class="downloadable-images-section" id="downloadableImagesSection" style="display: none; margin-bottom: 20px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
            <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px 20px;" onclick="toggleDownloadableImages()">
                <h4 style="color: #2c3e50; margin: 0; font-size: 18px; font-weight: 700;">📥 Figma Gui frame for test case</h4>
                <span id="downloadableToggle" style="color: #2c3e50; font-size: 20px; font-weight: bold;">▶</span>
            </div>
            <div id="downloadableContent" style="display: none; padding: 0 20px 20px 20px;">
                <div class="frame-list" id="frameList"></div>
            </div>
        </div>

        <!-- Console Output Window -->
        <div class="console-window" id="consoleWindow" style="display: none; margin-top: 20px; background: #1e1e1e; border-radius: 8px; border: 1px solid #333;">
            <div style="background: #333; padding: 10px 15px; border-radius: 8px 8px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <h4 style="color: #fff; margin: 0; font-size: 14px;">🖥️ Test Executor Console Output</h4>
                <div>
                    <button id="clearConsole" style="padding: 4px 8px; background: #666; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; margin-right: 5px;">Clear</button>
                    <button id="closeConsole" style="padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">Close</button>
                </div>
            </div>
            <div id="consoleOutput" style="padding: 15px; color: #00ff00; font-family: 'Courier New', monospace; font-size: 12px; height: 300px; overflow-y: auto; background: #1e1e1e;">
                <div style="color: #888;">Test Executor Console - Ready</div>
            </div>
        </div>

        <!-- Individual Operations Section -->
        <div class="individual-sections" style="margin-top: 30px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
            <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px 20px;" onclick="toggleIndividualOperations()">
                <h3 style="color: #2c3e50; margin: 0; font-size: 16px;">⚙️ Individual Operations</h3>
                <span id="individualToggle" style="color: #007bff; font-size: 20px; font-weight: bold;">▶</span>
            </div>
            <div id="individualContent" style="display: none; padding: 0 20px 20px 20px;">
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button class="export-button" id="exportButton" style="flex: 1; padding: 12px; font-size: 14px; height: 48px; display: flex; align-items: center; justify-content: center; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer;">📥 Export Frames Only</button>
                    <button class="ai-button" id="generateTestCasesButton" style="flex: 1; padding: 12px; background: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; height: 48px; display: flex; align-items: center; justify-content: center;">🤖 AI Test Cases Only</button>
                </div>
                <div id="testCaseOutput" style="display: none; margin-top: 15px;">
                    <h4 style="color: #2c3e50; margin-bottom: 10px;">Generated Test Cases:</h4>
                    <textarea id="testCaseText" readonly style="width: 100%; height: 200px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 12px; background: #f8f9fa;"></textarea>
                    <button id="downloadTestCases" style="margin-top: 10px; padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Download testcases.txt</button>
                </div>
            </div>
        </div>

        <!-- Manual Test Execution Section -->
        <div class="exe-section" style="margin-top: 20px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
            <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px 20px;" onclick="toggleManualExecution()">
                <h3 style="color: #2c3e50; margin: 0; font-size: 16px;">🖥️ Manual Test Execution</h3>
                <span id="manualToggle" style="color: #007bff; font-size: 20px; font-weight: bold;">▶</span>
            </div>
            <div id="manualContent" style="display: none; padding: 0 20px 20px 20px;">
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button class="exe-button" id="selectExeButton" style="flex: 1; padding: 12px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">📂 Select .exe File</button>
                    <button class="exe-button" id="runExeButton" style="flex: 1; padding: 12px; background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;" disabled>▶️ Run Selected Exe</button>
                </div>
                <div id="selectedExePath" style="font-size: 12px; color: #6c757d; word-break: break-all; font-style: italic;"></div>
            </div>
        </div>
    </div>

    <script>
        class FigmaExporter {
            constructor() {
                this.apiToken = document.getElementById('apiToken').value;
                this.fileId = document.getElementById('fileId').value;
                this.baseUrl = 'https://api.figma.com/v1';
                this.frames = [];
                this.exportedCount = 0;
                
                this.initializeEventListeners();
            }

            // Get current AI configuration from UI
            getAIConfig() {
                return {
                    apiUrl: document.getElementById('aiApiUrl').value || 'https://api.mistral.ai',
                    apiKey: document.getElementById('aiApiKey').value,
                    model: document.getElementById('aiModel').value || 'mistral-large-latest'
                };
            }

            initializeEventListeners() {
                document.getElementById('exportButton').addEventListener('click', () => {
                    this.exportAllFrames();
                });

                // Exe runner event listeners
                document.getElementById('selectExeButton').addEventListener('click', () => {
                    this.selectExeFile();
                });

                document.getElementById('runExeButton').addEventListener('click', () => {
                    this.runSelectedExe();
                });

                // AI test case generator event listeners
                document.getElementById('generateTestCasesButton').addEventListener('click', () => {
                    this.generateTestCases();
                });

                document.getElementById('downloadTestCases').addEventListener('click', () => {
                    this.downloadTestCases();
                });

                // Full width unified button event listener (main button)
                const unifiedButtonFullWidth = document.getElementById('unifiedButtonFullWidth');
                if (unifiedButtonFullWidth) {
                    unifiedButtonFullWidth.addEventListener('click', () => {
                        this.runUnifiedProcess();
                    });
                }

                // Prompt toggle event listener
                document.getElementById('togglePrompt').addEventListener('click', () => {
                    this.togglePromptDisplay();
                });

                // Console window event listeners
                document.getElementById('clearConsole').addEventListener('click', () => {
                    this.clearConsoleOutput();
                });

                document.getElementById('closeConsole').addEventListener('click', () => {
                    this.hideConsoleWindow();
                });

                // Additional download and copy button event listeners
                const downloadTestCasesExpanded = document.getElementById('downloadTestCasesExpanded');
                if (downloadTestCasesExpanded) {
                    downloadTestCasesExpanded.addEventListener('click', () => {
                        this.downloadTestCases();
                    });
                }

                const copyTestCases = document.getElementById('copyTestCases');
                if (copyTestCases) {
                    copyTestCases.addEventListener('click', () => {
                        this.copyTestCasesToClipboard();
                    });
                }
            }

            // Unified process that runs everything in sequence
            async runUnifiedProcess() {
                const unifiedButtonFullWidth = document.getElementById('unifiedButtonFullWidth');
                const originalText = unifiedButtonFullWidth ? unifiedButtonFullWidth.textContent : '';
                
                // Disable the main button and start processing
                if (unifiedButtonFullWidth) {
                    unifiedButtonFullWidth.disabled = true;
                    unifiedButtonFullWidth.textContent = '🔄 Processing Everything...';
                    // Keep yellow color during processing
                    unifiedButtonFullWidth.style.background = 'linear-gradient(135deg, #ffc107 0%, #fd7e14 100%)';
                }
                
                this.hideStatus();
                this.hideProgress(); // Hide the 5-step progress block
                this.activateWorkflowProgress(); // Activate the WORKFLOW PROGRESS section
                
                try {
                    this.showStatus('Starting unified process: Frames + Test Cases', 'info');
                    
                    // Step 1: Connect to Figma API
                    this.markWorkflowStepActive(1); // Blink Figma Connect step
                    this.showStatus('Step 1/5: Connecting to Figma API...', 'info');
                    this.updateButtonProgress(1); // Update button color for step 1
                    const frames = await this.getFrames();
                    this.markWorkflowStepCompleted(1);
                    await new Promise(resolve => setTimeout(resolve, 1500)); // Visual delay for step completion
                    
                    // Step 2: Extract design data
                    this.markWorkflowStepActive(2); // Blink JSON Process step
                    this.showStatus('Step 2/5: Extracting design data and interactions...', 'info');
                    this.updateButtonProgress(2);
                    const fileData = await this.makeApiRequest(`/files/${this.fileId}?geometry=paths`);
                    this.markWorkflowStepCompleted(2);
                    await new Promise(resolve => setTimeout(resolve, 1500)); // Visual delay for step completion
                    
                    // Step 3: AI Analysis with Prompt Display
                    this.markWorkflowStepActive(3); // Blink AI Analysis step
                    this.showStatus('Step 3/5: Preparing AI analysis with AI models...', 'info');
                    this.updateButtonProgress(3);
                    
                    // Create and display the prompt being sent to Mistral
                    const prototypeData = this.extractPrototypeData(fileData);
                    const prompt = this.createMistralPrompt(prototypeData);
                    
                    // Show the Mistral JSON section with the prototype data
                    this.showMistralJsonSection(prototypeData);
                    
                    let testResult;
                    
                    // Check if running in desktop mode (Electron) vs web browser
                    console.log('Desktop detection - window.electronAPI:', !!window.electronAPI);
                    if (window.electronAPI) {
                        // Desktop mode - make direct API call to Mistral
                        console.log('Using desktop mode for test case generation');
                        this.showStatus('Step 3/5: Calling AI directly from desktop...', 'info');
                        testResult = await this.generateTestCasesDesktop(fileData);
                    } else {
                        // Web mode - use Express server
                        const aiConfig = this.getAIConfig();
                        const response = await fetch('/api/generate-test-cases', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ 
                                figmaData: fileData, 
                                aiConfig: aiConfig
                            })
                        });

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({}));
                            throw new Error(`AI Error ${response.status}: ${errorData.message || response.statusText}`);
                        }

                        testResult = await response.json();
                    }
                    if (!testResult.success || !testResult.testCases) {
                        throw new Error(testResult.message || 'Failed to generate test cases');
                    }
                    this.markWorkflowStepCompleted(3);
                    await new Promise(resolve => setTimeout(resolve, 1500)); // Visual delay for step completion

                    // Step 4: Generate test cases
                    this.markWorkflowStepActive(4); // Blink Generate test case step
                    this.showStatus('Step 4/5: Generating test cases...', 'info');
                    this.updateButtonProgress(4);
                    
                    // Process frames in chunks and download
                    this.showFrameList();
                    frames.forEach(frame => this.addFrameToList(frame));
                    
                    const chunkSize = 50;
                    const chunks = [];
                    for (let i = 0; i < frames.length; i += chunkSize) {
                        chunks.push(frames.slice(i, i + chunkSize));
                    }

                    for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                        const chunk = chunks[chunkIndex];
                        const frameIds = chunk.map(f => f.id);
                        
                        const imageUrls = await this.exportFrames(frameIds);
                        
                        const downloadPromises = chunk.map(frame => {
                            const imageUrl = imageUrls[frame.id];
                            if (imageUrl) {
                                return this.downloadImage(frame.id, imageUrl, frame.name);
                            } else {
                                this.updateFrameStatus(frame.id, 'failed', 'No URL');
                                return Promise.resolve();
                            }
                        });
                        
                        await Promise.all(downloadPromises);
                        
                        if (chunkIndex < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }

                    // Display and download test cases
                    this.displayTestCases(testResult.testCases);
                    
                    // Auto-download test cases
                    if (window.electronAPI) {
                        await this.saveTestCasesDesktop();
                    } else {
                        this.saveTestCasesWeb();
                    }
                    this.markWorkflowStepCompleted(4);
                    await new Promise(resolve => setTimeout(resolve, 1500)); // Visual delay for step completion
                    
                    // Step 5: Auto execute (desktop only)
                    this.markWorkflowStepActive(5); // Blink Auto Execute step
                    this.showStatus('Step 5/5: Preparing auto execution...', 'info');
                    this.updateButtonProgress(5);
                    
                    // Run testexecutor.bat if on desktop
                    if (window.electronAPI) {
                        try {
                            await this.runTestExecutor();
                            this.markWorkflowStepCompleted(5);
                            this.showStatus(`✅ Success! Downloaded ${frames.length} frames, generated ${testResult.testCases.split('\n').filter(line => line.trim()).length} test cases, and launched test executor`, 'success');
                        } catch (error) {
                            this.markWorkflowStepCompleted(5);
                            this.showStatus(`✅ Partial Success! Downloaded ${frames.length} frames and generated test cases, but test executor failed: ${error.message}`, 'info');
                        }
                    } else {
                        this.markWorkflowStepCompleted(5);
                        this.showStatus(`✅ Success! Downloaded ${frames.length} frames and generated ${testResult.testCases.split('\n').filter(line => line.trim()).length} test cases. Use desktop version for auto execution.`, 'success');
                    }

                } catch (error) {
                    this.showStatus(`Error in unified process: ${error.message}`, 'error');
                    console.error('Unified process error:', error);
                } finally {
                    // Stop workflow progress animation and keep all tick marks visible
                    this.deactivateWorkflowProgress();
                    
                    // Final green completion state
                    if (unifiedButtonFullWidth) {
                        unifiedButtonFullWidth.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                        unifiedButtonFullWidth.innerHTML = '✅ Task Completed Successfully';
                        unifiedButtonFullWidth.disabled = false;
                    }
                    
                    // Reset button after 3 seconds
                    setTimeout(() => {
                        if (unifiedButtonFullWidth) {
                            unifiedButtonFullWidth.style.background = 'linear-gradient(135deg, #ffc107 0%, #fd7e14 100%)';
                            unifiedButtonFullWidth.textContent = originalText;
                        }
                    }, 3000);
                }
            }

            // Enhanced Progress Management
            updateProgressSteps(currentStep) {
                const steps = ['step1', 'step2', 'step3', 'step4', 'step5'];
                
                steps.forEach((stepId, index) => {
                    const stepElement = document.getElementById(stepId);
                    stepElement.classList.remove('active', 'completed', 'processing');
                    
                    if (index < currentStep - 1) {
                        stepElement.classList.add('completed');
                    } else if (index === currentStep - 1) {
                        stepElement.classList.add('active');
                    }
                });
            }

            // Keep steps visible and mark as completed without hiding
            markStepCompleted(stepNumber) {
                const stepElement = document.getElementById(`step${stepNumber}`);
                if (stepElement) {
                    stepElement.classList.remove('active', 'processing');
                    stepElement.classList.add('completed');
                }
            }

            // Simple button progress - just keep yellow during progress, green at completion
            updateButtonProgress(stepNumber) {
                const unifiedButtonFullWidth = document.getElementById('unifiedButtonFullWidth');
                if (!unifiedButtonFullWidth) return;
                
                // Keep yellow color during all progress steps
                if (stepNumber < 5) {
                    unifiedButtonFullWidth.style.background = 'linear-gradient(135deg, #ffc107 0%, #fd7e14 100%)';
                    unifiedButtonFullWidth.style.boxShadow = '0 6px 20px rgba(255, 193, 7, 0.3)';
                } else {
                    // Turn green only at final completion
                    unifiedButtonFullWidth.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                    unifiedButtonFullWidth.style.boxShadow = '0 6px 20px rgba(40, 167, 69, 0.3)';
                }
            }

            // Show step as processing (blinking)
            markStepProcessing(stepNumber) {
                const stepElement = document.getElementById(`step${stepNumber}`);
                if (stepElement) {
                    stepElement.classList.remove('active', 'completed');
                    stepElement.classList.add('processing');
                }
            }

            // Desktop mode: Direct API call to configured AI provider
            async generateTestCasesDesktop(figmaData) {
                try {
                    const aiConfig = this.getAIConfig();
                    const prototypeData = this.extractPrototypeData(figmaData);
                    const prompt = this.createMistralPrompt(prototypeData);
                    
                    // Construct API endpoint based on configuration
                    let apiEndpoint = `${aiConfig.apiUrl.replace(/\/$/, '')}/v1/chat/completions`;
                    
                    const response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${aiConfig.apiKey}`
                        },
                        body: JSON.stringify({
                            model: aiConfig.model,
                            messages: [
                                {
                                    role: 'user',
                                    content: prompt
                                }
                            ],
                            max_tokens: 4000,
                            temperature: 0.3
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(`AI API Error ${response.status}: ${errorData.message || response.statusText}`);
                    }

                    const result = await response.json();
                    
                    if (!result.choices || !result.choices[0] || !result.choices[0].message) {
                        throw new Error('Invalid response from AI provider');
                    }

                    return {
                        success: true,
                        testCases: result.choices[0].message.content
                    };
                } catch (error) {
                    console.error('Desktop test case generation error:', error);
                    return {
                        success: false,
                        message: error.message || 'Failed to generate test cases in desktop mode'
                    };
                }
            }

            updateProgress(percentage, text, step = null) {
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                const progressPercentage = document.getElementById('progressPercentage');
                
                progressFill.style.width = percentage + '%';
                progressText.textContent = text;
                progressPercentage.textContent = Math.round(percentage) + '%';
                
                if (step) {
                    this.updateProgressSteps(step);
                }
            }

            // Prompt Display Management
            togglePromptDisplay() {
                const promptContent = document.getElementById('promptContent');
                if (promptContent.style.display === 'none') {
                    promptContent.style.display = 'block';
                } else {
                    promptContent.style.display = 'none';
                }
            }

            showPromptSection(prompt) {
                const promptSection = document.getElementById('promptSection');
                const promptText = document.getElementById('promptText');
                
                promptText.value = prompt;
                promptSection.style.display = 'block';
            }

            hidePromptSection() {
                const promptSection = document.getElementById('promptSection');
                promptSection.style.display = 'none';
            }

            // Helper methods for prompt creation and prototype data extraction
            extractPrototypeData(figmaData) {
                const prototypeData = {
                    frames: [],
                    interactions: []
                };

                function traverseNode(node, parentType = '') {
                    if (node.type === 'FRAME') {
                        const frame = {
                            id: node.id,
                            name: node.name,
                            type: node.type,
                            absoluteBoundingBox: node.absoluteBoundingBox,
                            children: []
                        };

                        if (node.children) {
                            frame.children = extractTextAndInteractions(node.children);
                        }

                        if (node.interactions && node.interactions.length > 0) {
                            node.interactions.forEach((interaction) => {
                                prototypeData.interactions.push({
                                    sourceId: node.id,
                                    sourceName: node.name,
                                    trigger: interaction.trigger,
                                    actions: interaction.actions,
                                    absoluteBoundingBox: node.absoluteBoundingBox
                                });
                            });
                        }

                        prototypeData.frames.push(frame);
                    }

                    if (node.children) {
                        node.children.forEach((child) => traverseNode(child, node.type));
                    }
                }

                function extractTextAndInteractions(children) {
                    const extracted = [];
                    
                    children.forEach(child => {
                        if (child.type === 'TEXT' && child.characters) {
                            extracted.push({
                                type: 'TEXT',
                                characters: child.characters,
                                absoluteBoundingBox: child.absoluteBoundingBox
                            });
                        }
                        
                        if (child.interactions && child.interactions.length > 0) {
                            child.interactions.forEach((interaction) => {
                                prototypeData.interactions.push({
                                    sourceId: child.id,
                                    sourceName: child.name || 'Unnamed Element',
                                    trigger: interaction.trigger,
                                    actions: interaction.actions,
                                    absoluteBoundingBox: child.absoluteBoundingBox
                                });
                            });
                        }

                        if (child.children) {
                            extracted.push(...extractTextAndInteractions(child.children));
                        }
                    });

                    return extracted;
                }

                if (figmaData.document && figmaData.document.children) {
                    figmaData.document.children.forEach((page) => {
                        if (page.children) {
                            page.children.forEach((child) => traverseNode(child));
                        }
                    });
                }

                return prototypeData;
            }

            getFixedMistralPrompt() {
                return `You are a QA automation expert specializing in mobile app testing and test case generation. You are analyzing Figma design data to generate automated test cases for prototype interactions with precision and thoroughness.

CRITICAL REQUIREMENTS:
1. Each test case MUST include ALL 6 components in this exact order:
   <Test Case Name>,CLICK/CLICK_COORDS,coordinates/text,SLEEP,duration,CHECK,expected_text

2. CORRECT Test Case Format Examples:
   Navigate from Splash to Popular,CLICK_COORDS,540,960,SLEEP,2,CHECK,POPULAR RECIPES
   Navigate from Popular to Menu,CLICK_COORDS,74,83,SLEEP,2,CHECK,EXIT
   Navigate from Menu to Favorite,CLICK,FAVORITE RECIPES,SLEEP,2,CHECK,FAVORITE RECIPES

3. Command Rules:
   - CLICK_COORDS: Use for clickable areas without text. Format: CLICK_COORDS,x,y (where x,y are POSITIVE numbers)
   - CLICK: Use for buttons/text elements. Format: CLICK,TEXT_TO_CLICK
   - SLEEP: Always use SLEEP,2 (2 seconds wait)
   - CHECK: Verify destination screen text in UPPER CASE

4. MANDATORY Coordinate Guidelines:
   - Screen size: 1080 x 1920 pixels (width x height)
   - Top-left corner is (0,0)
   - Center coordinates: (540,960)
   - Menu button coordinates: (74,83)
   - ALL COORDINATES MUST BE POSITIVE NUMBERS ONLY
   - NEVER use negative coordinates like (-1295,-134) - this is WRONG
   - Valid coordinate range: X: 0-1080, Y: 0-1920
   - Examples of CORRECT coordinates: 74,83 or 540,960 or 200,400
   - Examples of WRONG coordinates: -1295,-134 or 1131,-134 (negative numbers are invalid)

5. Navigation Flow Rules:
   - Create sequential navigation paths
   - Navigate FROM source TO destination
   - Then continue FROM that destination to next screen
   - Include back navigation using menu buttons at coordinates like 74,83

6. Text Formatting:
   - ALL text in CLICK and CHECK commands must be UPPER CASE
   - Match exact spelling from Figma data
   - No extra spaces around commas

7. Required Output:
   - Generate test cases that follow complete user journeys
   - Include forward and backward navigation
   - Each line must be a complete test case with all 6 components
   - NO comments, explanations, or additional text
   - ONLY use POSITIVE coordinate values (0-1080 for X, 0-1920 for Y)

Figma Prototype Data:
[WILL BE POPULATED WITH FIGMA JSON DATA]

Generate complete test cases following the exact format above:`;
            }

            createMistralPrompt(prototypeData) {
                return `You are a QA automation expert specializing in mobile app testing and test case generation. You are analyzing Figma design data to generate automated test cases for prototype interactions with precision and thoroughness.

CRITICAL REQUIREMENTS:
1. Each test case MUST include ALL 6 components in this exact order:
   <Test Case Name>,CLICK/CLICK_COORDS,coordinates/text,SLEEP,duration,CHECK,expected_text

2. CORRECT Test Case Format Examples:
   Navigate from Splash to Popular,CLICK_COORDS,540,960,SLEEP,2,CHECK,POPULAR RECIPES
   Navigate from Popular to Menu,CLICK_COORDS,74,83,SLEEP,2,CHECK,EXIT
   Navigate from Menu to Favorite,CLICK,FAVORITE RECIPES,SLEEP,2,CHECK,FAVORITE RECIPES

3. Command Rules:
   - CLICK_COORDS: Use for clickable areas without text. Format: CLICK_COORDS,x,y (where x,y are POSITIVE numbers)
   - CLICK: Use for buttons/text elements. Format: CLICK,TEXT_TO_CLICK
   - SLEEP: Always use SLEEP,2 (2 seconds wait)
   - CHECK: Verify destination screen text in UPPER CASE

4. MANDATORY Coordinate Guidelines:
   - Screen size: 1080 x 1920 pixels (width x height)
   - Top-left corner is (0,0)
   - Center coordinates: (540,960)
   - Menu button coordinates: (74,83)
   - ALL COORDINATES MUST BE POSITIVE NUMBERS ONLY
   - NEVER use negative coordinates like (-1295,-134) - this is WRONG
   - Valid coordinate range: X: 0-1080, Y: 0-1920
   - Examples of CORRECT coordinates: 74,83 or 540,960 or 200,400
   - Examples of WRONG coordinates: -1295,-134 or 1131,-134 (negative numbers are invalid)

5. Navigation Flow Rules:
   - Create sequential navigation paths
   - Navigate FROM source TO destination
   - Then continue FROM that destination to next screen
   - Include back navigation using menu buttons at coordinates like 74,83

6. Text Formatting:
   - ALL text in CLICK and CHECK commands must be UPPER CASE
   - Match exact spelling from Figma data
   - No extra spaces around commas

7. Required Output:
   - Generate test cases that follow complete user journeys
   - Include forward and backward navigation
   - Each line must be a complete test case with all 6 components
   - NO comments, explanations, or additional text
   - ONLY use POSITIVE coordinate values (0-1080 for X, 0-1920 for Y)

Figma Prototype Data:
${JSON.stringify(prototypeData, null, 2)}

Generate complete test cases following the exact format above:`;
            }

            // Console Output Management
            showConsoleWindow() {
                const consoleWindow = document.getElementById('consoleWindow');
                consoleWindow.style.display = 'block';
            }

            hideConsoleWindow() {
                const consoleWindow = document.getElementById('consoleWindow');
                consoleWindow.style.display = 'none';
            }

            addConsoleOutput(message, type = 'info') {
                const consoleOutput = document.getElementById('consoleOutput');
                const timestamp = new Date().toLocaleTimeString();
                
                let color = '#00ff00'; // default green
                if (type === 'error') color = '#ff4444';
                if (type === 'warning') color = '#ffaa00';
                if (type === 'info') color = '#00aaff';
                
                const logEntry = document.createElement('div');
                logEntry.style.color = color;
                logEntry.innerHTML = `[${timestamp}] ${message}`;
                
                consoleOutput.appendChild(logEntry);
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }

            clearConsoleOutput() {
                const consoleOutput = document.getElementById('consoleOutput');
                consoleOutput.innerHTML = '<div style="color: #888;">Test Executor Console - Cleared</div>';
            }

            // Auto-run testexecutor.bat functionality
            async runTestExecutor() {
                if (window.electronAPI) {
                    this.showConsoleWindow();
                    this.addConsoleOutput('Starting Test Executor...', 'info');
                    
                    try {
                        // For desktop version, run c:\testexecutor.bat
                        const result = await window.electronAPI.runExecutable('c:\\testexecutor.bat');
                        this.addConsoleOutput('Test Executor launched successfully', 'info');
                        
                        // Monitor output if available
                        if (result.output) {
                            result.output.split('\n').forEach(line => {
                                if (line.trim()) {
                                    this.addConsoleOutput(line, 'info');
                                }
                            });
                        }
                        
                    } catch (error) {
                        this.addConsoleOutput(`Error running Test Executor: ${error.message}`, 'error');
                        this.showStatus('Failed to run Test Executor: ' + error.message, 'error');
                        throw error;
                    }
                } else {
                    throw new Error('Test Executor can only run in desktop mode');
                }
            }

            // AI Test Case Generator methods
            async generateTestCases() {
                const generateButton = document.getElementById('generateTestCasesButton');
                generateButton.disabled = true;
                generateButton.textContent = 'Generating Test Cases...';
                
                this.showStatus('Fetching Figma file data for AI analysis...', 'info');
                this.showProgress();
                this.updateProgress(10, 'Loading Figma file data...');

                try {
                    // Step 1: Get the full Figma file data including prototypes
                    const fileData = await this.makeApiRequest(`/files/${this.fileId}?geometry=paths`);
                    this.updateProgress(30, 'Analyzing prototype interactions...');

                    // Step 2: Create and display the prompt
                    const prototypeData = this.extractPrototypeData(fileData);
                    const prompt = this.createMistralPrompt(prototypeData);
                    
                    // Show the Mistral JSON section with the prototype data
                    this.showMistralJsonSection(prototypeData);

                    // Step 3: Send to Mistral AI for test case generation
                    this.updateProgress(60, 'Sending to Mistral AI...');
                    let result;
                    
                    if (window.electronAPI) {
                        // Desktop mode - direct API call to Mistral
                        result = await this.generateTestCasesDesktop(fileData);
                    } else {
                        // Web mode - use Express server
                        const response = await fetch('/api/generate-test-cases', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ figmaData: fileData, mistralApiKey: this.mistralKey })
                        });

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({}));
                            throw new Error(`AI Error ${response.status}: ${errorData.message || response.statusText}`);
                        }

                        this.updateProgress(80, 'Processing AI response...');
                        result = await response.json();
                    }
                    
                    if (result.success && result.testCases) {
                        this.updateProgress(100, 'Test cases generated successfully!');
                        this.displayTestCases(result.testCases);
                        this.showStatus(`Generated ${result.testCases.split('\n').filter(line => line.trim()).length} test cases`, 'success');
                    } else {
                        throw new Error(result.message || 'Failed to generate test cases');
                    }

                } catch (error) {
                    this.showStatus(`Error generating test cases: ${error.message}`, 'error');
                    console.error('Test case generation error:', error);
                } finally {
                    this.hideProgress();
                    generateButton.disabled = false;
                    generateButton.textContent = 'Generate Test Cases from Figma';
                }
            }

            displayTestCases(testCases) {
                // Update original section (for backward compatibility)
                const outputDiv = document.getElementById('testCaseOutput');
                const textArea = document.getElementById('testCaseText');
                
                textArea.value = testCases;
                outputDiv.style.display = 'block';
                
                // Update new expandable test cases section
                this.showTestCasesSection(testCases);
                
                this.generatedTestCases = testCases;
            }

            showTestCasesSection(testCases) {
                const section = document.getElementById('testCasesSection');
                const textArea = document.getElementById('testCasesText');
                const content = document.getElementById('testCasesContent');
                const toggle = document.getElementById('testCasesToggle');
                
                textArea.value = testCases;
                section.style.display = 'block';
                
                // Keep collapsed initially but user can expand
                content.style.display = 'none';
                toggle.textContent = '▶';
            }

            showMistralJsonSection(prototypeData) {
                const section = document.getElementById('mistralJsonSection');
                const textArea = document.getElementById('mistralJsonText');
                const content = document.getElementById('mistralJsonContent');
                const toggle = document.getElementById('mistralJsonToggle');
                
                textArea.value = JSON.stringify(prototypeData, null, 2);
                section.style.display = 'block';
                
                // Keep collapsed initially but user can expand
                content.style.display = 'none';
                toggle.textContent = '▶';
            }

            downloadTestCases() {
                if (!this.generatedTestCases) {
                    this.showStatus('No test cases to download', 'error');
                    return;
                }

                try {
                    if (window.electronAPI) {
                        // Desktop version - use Electron's file save dialog
                        this.saveTestCasesDesktop();
                    } else {
                        // Web version - use browser download
                        this.saveTestCasesWeb();
                    }
                } catch (error) {
                    this.showStatus(`Error downloading test cases: ${error.message}`, 'error');
                }
            }

            saveTestCasesWeb() {
                const blob = new Blob([this.generatedTestCases], { type: 'text/plain' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'testcases.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                this.showStatus('Test cases downloaded as testcases.txt', 'success');
            }

            async copyTestCasesToClipboard() {
                try {
                    if (this.generatedTestCases) {
                        await navigator.clipboard.writeText(this.generatedTestCases);
                        this.showStatus('Test cases copied to clipboard successfully', 'success');
                    } else {
                        this.showStatus('No test cases available to copy', 'error');
                    }
                } catch (error) {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = this.generatedTestCases;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    this.showStatus('Test cases copied to clipboard', 'success');
                }
            }

            async saveTestCasesDesktop() {
                try {
                    // Save directly to C:\AutoExecutor\testcases.txt without dialog
                    const filePath = `C:\\AutoExecutor\\testcases.txt`;
                    const buffer = new TextEncoder().encode(this.generatedTestCases);
                    const result = await window.electronAPI.saveFile(filePath, Array.from(buffer));
                    
                    if (result.success) {
                        this.showStatus(`Test cases saved to: ${filePath}`, 'success');
                    } else {
                        this.showStatus(`Error saving file: ${result.message}`, 'error');
                    }
                } catch (error) {
                    this.showStatus(`Error saving test cases: ${error.message}`, 'error');
                }
            }

            // Exe runner methods
            async selectExeFile() {
                try {
                    if (window.electronAPI) {
                        const exePath = await window.electronAPI.selectExeFile();
                        if (exePath) {
                            this.selectedExePath = exePath;
                            document.getElementById('selectedExePath').textContent = `Selected: ${exePath}`;
                            document.getElementById('runExeButton').disabled = false;
                            this.showStatus('Executable file selected successfully', 'success');
                        }
                    } else {
                        this.showStatus('This feature only works in the desktop app. Please run with Electron.', 'error');
                    }
                } catch (error) {
                    this.showStatus(`Error selecting file: ${error.message}`, 'error');
                }
            }

            async runSelectedExe() {
                if (!this.selectedExePath) {
                    this.showStatus('Please select an executable file first', 'error');
                    return;
                }

                try {
                    this.showStatus('Starting executable...', 'info');
                    const result = await window.electronAPI.executeExe(this.selectedExePath);
                    
                    if (result.success) {
                        this.showStatus(`Executable started successfully (PID: ${result.pid})`, 'success');
                    } else {
                        this.showStatus(`Failed to start executable: ${result.message}`, 'error');
                    }
                } catch (error) {
                    this.showStatus(`Error running executable: ${error.message}`, 'error');
                }
            }

            showStatus(message, type = 'info') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
                statusEl.style.display = 'block';
            }

            hideStatus() {
                document.getElementById('status').style.display = 'none';
            }

            showProgress() {
                document.getElementById('progress').style.display = 'block';
            }

            hideProgress() {
                document.getElementById('progress').style.display = 'none';
            }

            // Methods for individual step animation only
            activateWorkflowProgress() {
                // No change to main section background - only individual steps will animate
            }

            deactivateWorkflowProgress() {
                // Remove all active step animations
                const activeSteps = document.querySelectorAll('.workflow-step-active');
                activeSteps.forEach(step => {
                    step.classList.remove('workflow-step-active');
                });
            }

            markWorkflowStepActive(stepNumber) {
                // Remove any previous active step animations
                const activeSteps = document.querySelectorAll('.workflow-step-active');
                activeSteps.forEach(step => {
                    step.classList.remove('workflow-step-active');
                    // Reset to default background
                    const originalStyle = step.getAttribute('data-original-style');
                    if (originalStyle) {
                        step.setAttribute('style', originalStyle);
                    }
                });

                // Find the specific step and make it active
                const stepElements = document.querySelectorAll('#descriptionContent > div');
                if (stepElements[stepNumber - 1]) {
                    const stepDiv = stepElements[stepNumber - 1];
                    
                    // Store original style
                    if (!stepDiv.getAttribute('data-original-style')) {
                        stepDiv.setAttribute('data-original-style', stepDiv.getAttribute('style') || '');
                    }
                    
                    // Force yellow background with inline style
                    const currentStyle = stepDiv.getAttribute('style') || '';
                    const newStyle = currentStyle.replace(/background:[^;]+;?/g, '') + 'background: #ffff00 !important;';
                    stepDiv.setAttribute('style', newStyle);
                    stepDiv.classList.add('workflow-step-active');
                }
            }

            markWorkflowStepCompleted(stepNumber) {
                // Remove active animation and add completion state
                const stepElements = document.querySelectorAll('#descriptionContent > div');
                if (stepElements[stepNumber - 1]) {
                    const stepDiv = stepElements[stepNumber - 1];
                    stepDiv.classList.remove('workflow-step-active');
                    
                    // Force green background with inline style
                    const currentStyle = stepDiv.getAttribute('style') || '';
                    const newStyle = currentStyle.replace(/background:[^;]+;?/g, '') + 'background: #90EE90 !important;';
                    stepDiv.setAttribute('style', newStyle);
                    stepDiv.classList.add('workflow-step-completed');
                }
            }

            resetWorkflowProgress() {
                // Remove all active and completed states from individual steps only
                const allSteps = document.querySelectorAll('#descriptionContent > div');
                allSteps.forEach(step => {
                    step.classList.remove('workflow-step-active', 'workflow-step-completed');
                    // Restore original background styles
                    const originalStyle = step.getAttribute('data-original-style');
                    if (originalStyle) {
                        step.setAttribute('style', originalStyle);
                    }
                });
            }

            updateProgress(percentage, text) {
                document.getElementById('progressFill').style.width = `${percentage}%`;
                document.getElementById('progressText').textContent = text;
            }

            showFrameList() {
                document.getElementById('frameList').style.display = 'block';
            }

            addFrameToList(frame) {
                const frameList = document.getElementById('frameList');
                const frameItem = document.createElement('div');
                frameItem.className = 'frame-item';
                frameItem.id = `frame-${frame.id}`;
                frameItem.innerHTML = `
                    <span class="frame-name">${frame.name}</span>
                    <span class="frame-status" id="status-${frame.id}">Pending</span>
                `;
                frameList.appendChild(frameItem);
                
                // Show Figma Gui frame for test case section when frames are added (keep collapsed initially)
                const downloadableSection = document.getElementById('downloadableImagesSection');
                const downloadableContent = document.getElementById('downloadableContent');
                const downloadableToggle = document.getElementById('downloadableToggle');
                
                if (downloadableSection && downloadableContent && downloadableToggle) {
                    downloadableSection.style.display = 'block';
                    // Keep collapsed initially but user can expand
                    downloadableContent.style.display = 'none';
                    downloadableToggle.textContent = '▶';
                }
            }

            updateFrameStatus(frameId, status, text) {
                const statusEl = document.getElementById(`status-${frameId}`);
                if (statusEl) {
                    statusEl.textContent = text;
                    statusEl.className = `frame-status ${status}`;
                }
            }

            async makeApiRequest(endpoint) {
                const response = await fetch(`${this.baseUrl}${endpoint}`, {
                    headers: {
                        'X-Figma-Token': this.apiToken
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`API Error ${response.status}: ${errorData.message || response.statusText}`);
                }

                return await response.json();
            }

            async getFrames() {
                this.showStatus('Fetching file structure...', 'info');
                this.updateProgress(10, 'Loading file data...');

                try {
                    const fileData = await this.makeApiRequest(`/files/${this.fileId}`);
                    const frames = [];

                    // Traverse the document tree to find all frames
                    const traverseNode = (node, pageName = '') => {
                        if (node.type === 'CANVAS') {
                            pageName = node.name;
                        }
                        
                        if (node.type === 'FRAME') {
                            const frame = {
                                id: node.id,
                                name: node.name,
                                page: pageName
                            };
                            frames.push(frame);
                            console.log('Found frame:', frame);
                        }

                        if (node.children) {
                            node.children.forEach(child => traverseNode(child, pageName));
                        }
                    };

                    fileData.document.children.forEach(page => traverseNode(page));

                    if (frames.length === 0) {
                        throw new Error('No frames found in the Figma file');
                    }

                    this.frames = frames;
                    this.showStatus(`Found ${frames.length} frames`, 'success');
                    this.updateProgress(25, `Found ${frames.length} frames`);
                    
                    return frames;
                } catch (error) {
                    this.showStatus(`Error fetching frames: ${error.message}`, 'error');
                    throw error;
                }
            }

            async exportFrames(frameIds) {
                this.updateProgress(30, 'Requesting frame exports...');

                try {
                    const params = new URLSearchParams({
                        ids: frameIds.join(','),
                        format: 'png',
                        scale: '2'
                    });

                    const exportData = await this.makeApiRequest(`/images/${this.fileId}?${params}`);
                    
                    if (!exportData.images || Object.keys(exportData.images).length === 0) {
                        throw new Error('No export URLs received from Figma API');
                    }

                    // Debug: Log which frames got URLs and which didn't
                    console.log('Export data received:', exportData);
                    frameIds.forEach(frameId => {
                        if (!exportData.images[frameId]) {
                            console.warn(`No export URL for frame ID: ${frameId}`);
                        }
                    });

                    // Check for any API errors in the response
                    if (exportData.err) {
                        console.error('Figma API returned error:', exportData.err);
                    }

                    this.updateProgress(50, 'Export URLs generated');
                    return exportData.images;
                } catch (error) {
                    this.showStatus(`Error exporting frames: ${error.message}`, 'error');
                    throw error;
                }
            }

            async downloadImage(frameId, imageUrl, frameName) {
                this.updateFrameStatus(frameId, 'downloading', 'Downloading...');
                
                try {
                    const response = await fetch(imageUrl);
                    if (!response.ok) {
                        throw new Error(`Download failed: ${response.statusText}`);
                    }

                    const blob = await response.blob();
                    
                    if (window.electronAPI) {
                        // Desktop mode - save directly to C:\AutoExecutor\screenshots
                        const arrayBuffer = await blob.arrayBuffer();
                        const buffer = Array.from(new Uint8Array(arrayBuffer));
                        const fileName = `${frameName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.png`;
                        const filePath = `C:\\AutoExecutor\\screenshots\\${fileName}`;
                        
                        const result = await window.electronAPI.saveFile(filePath, buffer);
                        if (result.success) {
                            this.updateFrameStatus(frameId, 'completed', 'Saved');
                            this.exportedCount++;
                        } else {
                            throw new Error(`Failed to save: ${result.message}`);
                        }
                    } else {
                        // Web mode - use browser download
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${frameName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        
                        this.updateFrameStatus(frameId, 'completed', 'Downloaded');
                        this.exportedCount++;
                    }
                    
                } catch (error) {
                    this.updateFrameStatus(frameId, 'failed', 'Failed');
                    console.error(`Failed to download frame ${frameName}:`, error);
                }
            }

            async exportAllFrames() {
                const exportButton = document.getElementById('exportButton');
                exportButton.disabled = true;
                exportButton.textContent = 'Exporting...';
                
                this.hideStatus();
                this.showProgress();
                this.exportedCount = 0;

                try {
                    // Step 1: Get all frames
                    const frames = await this.getFrames();
                    
                    // Step 2: Show frame list
                    this.showFrameList();
                    frames.forEach(frame => this.addFrameToList(frame));
                    
                    // Step 3: Export frames (batch process in chunks of 50)
                    const chunkSize = 50;
                    const chunks = [];
                    for (let i = 0; i < frames.length; i += chunkSize) {
                        chunks.push(frames.slice(i, i + chunkSize));
                    }

                    for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                        const chunk = chunks[chunkIndex];
                        const frameIds = chunk.map(f => f.id);
                        
                        this.updateProgress(
                            50 + (chunkIndex / chunks.length) * 30, 
                            `Processing batch ${chunkIndex + 1} of ${chunks.length}...`
                        );
                        
                        const imageUrls = await this.exportFrames(frameIds);
                        
                        // Step 4: Download all images
                        const downloadPromises = chunk.map(frame => {
                            const imageUrl = imageUrls[frame.id];
                            if (imageUrl) {
                                return this.downloadImage(frame.id, imageUrl, frame.name);
                            } else {
                                console.error(`Failed to download frame ${frame.name}:`, {
                                    frameId: frame.id,
                                    frameName: frame.name,
                                    reason: 'No export URL received from Figma API',
                                    availableIds: Object.keys(imageUrls)
                                });
                                this.updateFrameStatus(frame.id, 'failed', 'No URL');
                                return Promise.resolve();
                            }
                        });
                        
                        await Promise.all(downloadPromises);
                        
                        // Rate limiting between batches
                        if (chunkIndex < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }

                    this.updateProgress(100, 'Export completed!');
                    this.showStatus(`Successfully exported ${this.exportedCount} of ${frames.length} frames`, 'success');
                    
                } catch (error) {
                    console.error('Export failed:', error);
                    this.showStatus(`Export failed: ${error.message}`, 'error');
                } finally {
                    exportButton.disabled = false;
                    exportButton.textContent = 'Export All Frames';
                    
                    // Hide progress after 3 seconds
                    setTimeout(() => {
                        this.hideProgress();
                    }, 3000);
                }
            }
        }

        // Toggle description functionality
        function toggleDescription() {
            const content = document.getElementById('descriptionContent');
            const toggle = document.getElementById('descriptionToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Toggle individual operations functionality
        function toggleIndividualOperations() {
            const content = document.getElementById('individualContent');
            const toggle = document.getElementById('individualToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Toggle manual execution functionality
        function toggleManualExecution() {
            const content = document.getElementById('manualContent');
            const toggle = document.getElementById('manualToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Toggle Figma Resources functionality
        function toggleFigmaResources() {
            const content = document.getElementById('figmaResourcesContent');
            const toggle = document.getElementById('figmaResourcesToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Toggle AI configuration functionality
        function toggleAIConfig() {
            const content = document.getElementById('aiConfigContent');
            const toggle = document.getElementById('aiConfigToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Toggle Mistral Prompt functionality
        function toggleMistralPrompt() {
            const content = document.getElementById('mistralPromptContent');
            const toggle = document.getElementById('mistralPromptToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Toggle Mistral JSON functionality
        function toggleMistralJson() {
            const content = document.getElementById('mistralJsonContent');
            const toggle = document.getElementById('mistralJsonToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Toggle Test Cases functionality
        function toggleTestCases() {
            const content = document.getElementById('testCasesContent');
            const toggle = document.getElementById('testCasesToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        function toggleDownloadableImages() {
            const content = document.getElementById('downloadableContent');
            const toggle = document.getElementById('downloadableToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Initialize the exporter when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const exporter = new FigmaExporter();
            
            // Initialize description as collapsed
            document.getElementById('descriptionContent').style.display = 'none';
            document.getElementById('descriptionToggle').textContent = '▶';
            
            // Initialize individual operations as collapsed
            document.getElementById('individualContent').style.display = 'none';
            document.getElementById('individualToggle').textContent = '▶';
            
            // Initialize manual execution as collapsed
            document.getElementById('manualContent').style.display = 'none';
            document.getElementById('manualToggle').textContent = '▶';
            
            // Initialize description section as collapsed
            document.getElementById('descriptionContent').style.display = 'none';
            document.getElementById('descriptionToggle').textContent = '▶';
            
            // Initialize AI config as collapsed
            document.getElementById('aiConfigContent').style.display = 'none';
            document.getElementById('aiConfigToggle').textContent = '▶';
            
            // Initialize the Mistral prompt section as collapsed
            document.getElementById('mistralPromptContent').style.display = 'none';
            document.getElementById('mistralPromptToggle').textContent = '▶';
            
            // Populate the fixed Mistral prompt
            const mistralPromptText = document.getElementById('mistralPromptText');
            if (mistralPromptText) {
                mistralPromptText.value = exporter.getFixedMistralPrompt();
            }
            
            // Add event listeners for new buttons with null checks
            const downloadButton = document.getElementById('downloadTestCasesExpanded');
            if (downloadButton) {
                downloadButton.addEventListener('click', () => {
                    exporter.downloadTestCases();
                });
            }
            
            const copyButton = document.getElementById('copyTestCases');
            if (copyButton) {
                copyButton.addEventListener('click', () => {
                    const testCasesText = document.getElementById('testCasesText').value;
                    if (testCasesText) {
                        navigator.clipboard.writeText(testCasesText).then(() => {
                            // Temporarily change button text to show success
                            const originalText = copyButton.textContent;
                            copyButton.textContent = '✅ Copied!';
                            setTimeout(() => {
                                copyButton.textContent = originalText;
                            }, 2000);
                        }).catch(() => {
                            alert('Failed to copy to clipboard. Please copy manually.');
                        });
                    } else {
                        alert('No test cases to copy. Generate test cases first.');
                    }
                });
            }
        });
    </script>
</body>
</html>
